<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Wendi's Blog]]></title>
  <link href="http://blog.ifyouseewendy.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://blog.ifyouseewendy.com/"/>
  <updated>2016-02-12T11:00:18+08:00</updated>
  <id>http://blog.ifyouseewendy.com/</id>
  <author>
    <name><![CDATA[wendi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Some Hash Tricks in Ruby]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2015/11/30/some-hash-tricks-in-ruby/"/>
    <updated>2015-11-30T16:17:38+08:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2015/11/30/some-hash-tricks-in-ruby</id>
    <content type="html"><![CDATA[<blockquote>
  <p>from <a href="http://blog.honeybadger.io/advanced-ruby-hash-techniques/">http://blog.honeybadger.io/advanced-ruby-hash-techniques/</a></p>
</blockquote>

<h3 id="strict-fetching">Strict fetching</h3>

<p><code>ruby
h = Hash.new { |hash, key| raise ArgumentError.new("No hash key: #{ key }") }
h[:a]=1
h[:a] # 1
h[:x] # raises ArgumentError: No hash key: x
</code></p>

<h3 id="modifying-defaults-after-initialization">Modifying defaults after initialization</h3>

<p>```ruby
h={}
h[:a] # nil
h.default = “new default”
h[:a] # “new default”</p>

<p>h.default_proc = Proc.new { Time.now.to_i }
h[:a] # 1435684014
```</p>

<h3 id="factorial-using-hash">Factorial using Hash</h3>

<p><code>ruby
factorial = Hash.new{|h,k| k &gt; 1 ? h[k] = h[k-1]*k : h[k] = 1 }
Factorail[4] # =&gt; 24
</code></p>

<h3 id="a-game-of-lazily-infinite-nested-hashes">A game of lazily infinite nested hashes</h3>

<p><code>ruby
generator = Proc.new do |hash, key|
  hash[key] = Hash.new(&amp;generator).merge( ['n', 's', 'e', 'w'][rand(4)] =&gt; 'You found me' )
end
dungeon = Hash.new &amp;generator
dungeon['n']            # =&gt; { "s" =&gt; "You found me" }
dungeon['n']['w']       # =&gt; { "e" =&gt; "You found me" }
dungeon['n']['w']['e']  # =&gt; "You found me"
</code></p>

<blockquote>
  <p>from <a href="https://endofline.wordpress.com/2010/12/24/hash-tricks/">https://endofline.wordpress.com/2010/12/24/hash-tricks</a></p>
</blockquote>

<h3 id="hash-returns-hashes-to-build-a-tree-structure">Hash returns hashes, to build a tree structure</h3>

<p>```ruby
tree_block = -&gt;(hash,k){ hash[k] = Hash.new(&amp;tree_block) }
opts = Hash.new(&amp;tree_block)</p>

<p>opts[‘dev’][‘db’][‘host’] = “localhost:2828”
opts[‘dev’][‘db’][‘user’] = “me”
opts[‘dev’][‘db’][‘password’] = “secret”
opts[‘test’][‘db’][‘host’] = “localhost:2828”
opts[‘test’][‘db’][‘user’] = “test_user”
opts[‘test’][‘db’][‘password’] = “test_secret”
opts
# =&gt; {
  “dev”  =&gt; {
    “db” =&gt; {
      “host”     =&gt; “localhost:2828”,
      “user”     =&gt; “me”,
      “password” =&gt; “secret”
    }
  },
  “test” =&gt; {
    “db” =&gt; {
      “host”     =&gt; “localhost:2828”,
      “user”     =&gt; “test_user”,
      “password” =&gt; “test_secret”
    }
  }
}
```</p>

<h3 id="use-hash-as-a-method">Use hash as a method</h3>

<p><code>ruby
require 'net/http'
http = Hash.new do |h,k|
  h[k] = Net::HTTP.get_response(URI(k)).body
  h.delete h.keys.first if h.length &gt; 3 # a caching layer
  h
end
</code></p>

<blockquote>
  <p>from Amadan posted on <a href="https://www.reddit.com/r/ruby/comments/29hr4x/whats_youre_favorite_ruby_trick_or_quirk_thata">https://www.reddit.com/r/ruby/comments/29hr4x/whats_youre_favorite_ruby_trick_or_quirk_thata</a></p>
</blockquote>

<h3 id="autovivifying-hashes-are-cool">Autovivifying hashes are cool</h3>

<p><code>ruby
autohash = Hash.new { |h, k| h[k] = Hash.new(&amp;h.default_proc) }
autohash[1][2][3][4][5][6][7] = 8
autohash # =&gt; {1=&gt;{2=&gt;{3=&gt;{4=&gt;{5=&gt;{6=&gt;{7=&gt;8}}}}}}}
</code></p>

<blockquote>
  <p>from The Buckblog <a href="http://weblog.jamisbuck.org/2015/11/14/little-things-refactoring-with-hashes.html">http://weblog.jamisbuck.org/2015/11/14/little-things-refactoring-with-hashes.html</a></p>
</blockquote>

<h3 id="refactor-case-statement">Refactor case statement</h3>

<p>before</p>

<p><code>ruby
klass = case params[:student_level]
  when :freshman, :sophomore then
    Student::Underclassman
  when :junior, :senior then
    Student::Upperclassman
  when :graduate
    Student::Graduate
  else
    Student::Unregistered
  end
student = klass.new(name, birthdate, address, phone)
</code></p>

<p>after</p>

<p>```ruby
STUDENT_LEVELS = Hash.new(Student::Unregistered).merge(
  freshman: Student::Underclassman,
  sophomore: Student::Underclassman,
  junior:    Student::Upperclassman,
  senior:    Student::Upperclassman,
  graduate:  Student::Graduate
)</p>

<p>klass = STUDENT_LEVELS[params[:student_level]]
student = klass.new(name, birthdate, address, phone)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[preload, eager_load, includes, references, and joins in Rails]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2015/11/11/preload-eager_load-includes-references-joins/"/>
    <updated>2015-11-11T23:25:17+08:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2015/11/11/preload-eager_load-includes-references-joins</id>
    <content type="html"><![CDATA[<p>There is always a confusion about these query methods. And after some digging, I’ve made my conclusion here: <code>includes</code> is the outstanding one.</p>

<p>Here comes the demonstation.</p>

<p><strong>Preparation</strong></p>

<p>Environment</p>

<ul>
  <li>Ruby: 2.2.2</li>
  <li>Rails: 4.2.2</li>
</ul>

<p>```ruby
# model and reference
class Blog &lt; ActiveRecord::Base
  has_many :posts</p>

<p># t.string   “name”
  # t.string   “author”
end</p>

<p>class Post &lt; ActiveRecord::Base
  belongs_to :blog</p>

<p># t.string   “title”
end</p>

<h1 id="seed">seed</h1>
<p>(1..3).each do |b_id|
  blog = Blog.create(name: “Blog #{b_id}”, author: ‘someone’)
  (1..5).each { |p_id| blog.posts.create(title: “Post #{b_id}-#{p_id}”) }
end
```</p>

<h3 id="preload">preload</h3>

<p>Always firing two separate queries.</p>

<p><code>sh
&gt; Blog.preload(:posts)
  Blog Load (3.2ms)  SELECT "blogs".* FROM "blogs"
  Post Load (1.2ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" IN (1, 2, 3)
</code></p>

<h3 id="eagerload">eager_load</h3>

<ul>
  <li>One query, LEFT OUTER JOINed in any query rather than loaded separately.</li>
  <li>JOIN first, then query by where clause. So you can query on referenced table, without an iteration of  <code>Enumerable#select</code>.</li>
  <li>Works just the same as <code>includes</code> + <code>references</code>.</li>
</ul>

<p>```sh
&gt; Blog.eager_load(:posts)
  SQL (0.4ms)  SELECT “blogs”.”id” AS t0_r0, “blogs”.”name” AS t0_r1, “blogs”.”author” AS t0_r2, “blogs”.”created_at” AS t0_r3, “blogs”.”updated_at” AS t0_r4, “posts”.”id” AS t1_r0, “posts”.”title” AS t1_r1, “posts”.”created_at” AS t1_r2, “posts”.”updated_at” AS t1_r3, “posts”.”blog_id” AS t1_r4 FROM “blogs” LEFT OUTER JOIN “posts” ON “posts”.”blog_id” = “blogs”.”id”</p>

<blockquote>
  <p>Blog.eager_load(:posts).where(name: ‘Blog 1’)
  SQL (0.4ms)  SELECT “blogs”.”id” AS t0_r0, “blogs”.”name” AS t0_r1, “blogs”.”author” AS t0_r2, “blogs”.”created_at” AS t0_r3, “blogs”.”updated_at” AS t0_r4, “posts”.”id” AS t1_r0, “posts”.”title” AS t1_r1, “posts”.”created_at” AS t1_r2, “posts”.”updated_at” AS t1_r3, “posts”.”blog_id” AS t1_r4 FROM “blogs” LEFT OUTER JOIN “posts” ON “posts”.”blog_id” = “blogs”.”id” WHERE “blogs”.”name” = ?  [[“name”, “Blog 1”]]</p>
</blockquote>

<blockquote>
  <p>Blog.eager_load(:posts).where(name: ‘Blog 1’).where(posts: {title: ‘Post 1-1’})
  SQL (0.4ms)  SELECT “blogs”.”id” AS t0_r0, “blogs”.”name” AS t0_r1, “blogs”.”author” AS t0_r2, “blogs”.”created_at” AS t0_r3, “blogs”.”updated_at” AS t0_r4, “posts”.”id” AS t1_r0, “posts”.”title” AS t1_r1, “posts”.”created_at” AS t1_r2, “posts”.”updated_at” AS t1_r3, “posts”.”blog_id” AS t1_r4 FROM “blogs” LEFT OUTER JOIN “posts” ON “posts”.”blog_id” = “blogs”.”id” WHERE “blogs”.”name” = ? AND “posts”.”title” = ?  [[“name”, “Blog 1”], [“title”, “Post 1-1”]]
```</p>
</blockquote>

<h3 id="includes">includes</h3>

<p>Behaves based on situations, intelligent!</p>

<p>Situation 1, just like <code>preload</code></p>

<p>```sh
&gt; Blog.includes(:posts)
  Blog Load (2.8ms)  SELECT “blogs”.* FROM “blogs”
  Post Load (0.7ms)  SELECT “posts”.* FROM “posts” WHERE “posts”.”blog_id” IN (1, 2, 3)</p>

<blockquote>
  <p>Blog.includes(:posts).where(name: ‘Blog 1’)
  Blog Load (0.7ms)  SELECT “blogs”.* FROM “blogs” WHERE “blogs”.”name” = ?  [[“name”, “Blog 1”]]
  Post Load (0.3ms)  SELECT “posts”.* FROM “posts” WHERE “posts”.”blog_id” IN (1)
```</p>
</blockquote>

<p>Situation 2, just like <code>eager_load</code>, <strong>fired by querying referenced table</strong></p>

<p><code>sh
&gt; Blog.includes(:posts).where(name: 'Blog 1').where(posts: {title: 'Post 1-1'})
  SQL (0.2ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."created_at" AS t1_r2, "posts"."updated_at" AS t1_r3, "posts"."blog_id" AS t1_r4 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE "blogs"."name" = ? AND "posts"."title" = ?  [["name", "Blog 1"], ["title", "Post 1-1"]]
</code></p>

<p><strong><em><code>includes</code> or <code>eager_load</code></em></strong></p>

<p>Consider this snippet:</p>

<p>```sh
&gt; Blog.includes(:posts).each{|blog| puts blog.posts.map(&amp;:title).join(‘,’) }
  Blog Load (0.3ms)  SELECT “blogs”.* FROM “blogs”
  Post Load (0.3ms)  SELECT “posts”.* FROM “posts” WHERE “posts”.”blog_id” IN (1, 2, 3)</p>

<blockquote>
  <p>Blog.eager_load(:posts).each{|blog| puts blog.posts.map(&amp;:title).join(‘,’) }                                                                                                                    SQL (0.9ms)
  SELECT “blogs”.”id” AS t0_r0, “blogs”.”name” AS t0_r1, “blogs”.”author” AS t0_r2, “blogs”.”created_at” AS t0_r3, “blogs”.”updated_at” AS t0_r4, “posts”.”id” AS t1_r0, “posts”.”title” AS t1_r1, “posts”.”created_at” AS t1_r2, “posts”.”updated_at” AS t1_r3, “posts”.”blog_id” AS t1_r4 FROM “blogs” LEFT OUTER JOIN “posts” ON “posts”.”blog_id” = “blogs”.”id”
```</p>
</blockquote>

<p>Both expressions return the same result, so should we prefer two seperated queries by <code>includes</code> (also <code>preload</code>) or the LEFT OUTER JOINed query by <code>eager_load</code>?</p>

<p>There is a <a href="http://www.akitaonrails.com/2008/5/26/rolling-with-rails-2-1-the-first-full-tutorial-part-2">blog post</a> by Fabio Akita talks about the change of Rails 2.1 (see the section entitled “Optimized Eager Loading”). Here are some references:</p>

<blockquote>
  <p>For some situations, the monster outer join becomes slower than many smaller queries.
The bottom line is: generally it seems better to split a monster join into smaller ones, as you’ve seen in the above example. This avoid the cartesian product overload problem.</p>
</blockquote>

<p>Example for SQL data returned from LEFT OUTER JOIN query</p>

<p><code>sh
sqlite&gt;  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."created_at" AS t1_r2, "posts"."updated_at" AS t1_r3, "posts"."blog_id" AS t1_r4 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id";
1|Blog 1|someone|2015-11-11 15:22:35.015095|2015-11-11 15:22:35.015095|1|Post 1-1|2015-11-11 15:22:35.053689|2015-11-11 15:22:35.053689|1
1|Blog 1|someone|2015-11-11 15:22:35.015095|2015-11-11 15:22:35.015095|2|Post 1-2|2015-11-11 15:22:35.058113|2015-11-11 15:22:35.058113|1
1|Blog 1|someone|2015-11-11 15:22:35.015095|2015-11-11 15:22:35.015095|3|Post 1-3|2015-11-11 15:22:35.062776|2015-11-11 15:22:35.062776|1
1|Blog 1|someone|2015-11-11 15:22:35.015095|2015-11-11 15:22:35.015095|4|Post 1-4|2015-11-11 15:22:35.065994|2015-11-11 15:22:35.065994|1
1|Blog 1|someone|2015-11-11 15:22:35.015095|2015-11-11 15:22:35.015095|5|Post 1-5|2015-11-11 15:22:35.069632|2015-11-11 15:22:35.069632|1
2|Blog 2|someone|2015-11-11 15:22:35.072871|2015-11-11 15:22:35.072871|6|Post 2-1|2015-11-11 15:22:35.078644|2015-11-11 15:22:35.078644|2
2|Blog 2|someone|2015-11-11 15:22:35.072871|2015-11-11 15:22:35.072871|7|Post 2-2|2015-11-11 15:22:35.081845|2015-11-11 15:22:35.081845|2
2|Blog 2|someone|2015-11-11 15:22:35.072871|2015-11-11 15:22:35.072871|8|Post 2-3|2015-11-11 15:22:35.084888|2015-11-11 15:22:35.084888|2
2|Blog 2|someone|2015-11-11 15:22:35.072871|2015-11-11 15:22:35.072871|9|Post 2-4|2015-11-11 15:22:35.087778|2015-11-11 15:22:35.087778|2
2|Blog 2|someone|2015-11-11 15:22:35.072871|2015-11-11 15:22:35.072871|10|Post 2-5|2015-11-11 15:22:35.090781|2015-11-11 15:22:35.090781|2
3|Blog 3|someone|2015-11-11 15:22:35.093902|2015-11-11 15:22:35.093902|11|Post 3-1|2015-11-11 15:22:35.097479|2015-11-11 15:22:35.097479|3
3|Blog 3|someone|2015-11-11 15:22:35.093902|2015-11-11 15:22:35.093902|12|Post 3-2|2015-11-11 15:22:35.103512|2015-11-11 15:22:35.103512|3
3|Blog 3|someone|2015-11-11 15:22:35.093902|2015-11-11 15:22:35.093902|13|Post 3-3|2015-11-11 15:22:35.108775|2015-11-11 15:22:35.108775|3
3|Blog 3|someone|2015-11-11 15:22:35.093902|2015-11-11 15:22:35.093902|14|Post 3-4|2015-11-11 15:22:35.112654|2015-11-11 15:22:35.112654|3
3|Blog 3|someone|2015-11-11 15:22:35.093902|2015-11-11 15:22:35.093902|15|Post 3-5|2015-11-11 15:22:35.117601|2015-11-11 15:22:35.117601|3
</code></p>

<blockquote>
  <p>The longer and more complex the result set, the more this matters because the more objects Rails would have to deal with. Allocating and deallocating several hundreds or thousands of small duplicated objects is never a good deal.</p>
</blockquote>

<p>As <code>includes</code> can behave the same as <code>eager_load</code> in one case, but better in the other case. My conclusion is, <strong>prefer <code>includes</code> over <code>eager_load</code></strong>.</p>

<h3 id="references">references</h3>

<ul>
  <li>Works only with <code>includes</code>, makes <code>includes</code> behaves like <code>eager_load</code></li>
</ul>

<p><code>sh
&gt; Blog.includes(:posts).where(name: 'Blog 1').references(:posts)
  SQL (0.2ms)  SELECT "blogs"."id" AS t0_r0, "blogs"."name" AS t0_r1, "blogs"."author" AS t0_r2, "blogs"."created_at" AS t0_r3, "blogs"."updated_at" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title" AS t1_r1, "posts"."created_at" AS t1_r2, "posts"."updated_at" AS t1_r3, "posts"."blog_id" AS t1_r4 FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id" WHERE "blogs"."name" = ?  [["name", "Blog 1"]]
</code></p>

<h3 id="joins">joins</h3>

<p><em>INNER JOIN</em>, compared to <code>eager_load</code> (<em>LEFT OUTER JOIN</em>).</p>

<p><code>sh
&gt; Blog.joins(:posts)
  Blog Load (0.2ms)  SELECT "blogs".* FROM "blogs" INNER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
</code></p>

<p><strong>compared to <code>eager_load</code></strong></p>

<p>Query by <code>joins</code> just returns the raw data, whereas the data from <code>eager_load</code> is filtered by Rails.</p>

<p><code>sh
&gt; Blog.joins(:posts).count
   (0.3ms)  SELECT COUNT(*) FROM "blogs" INNER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; 15
&gt; Blog.eager_load(:posts).count
   (0.4ms)  SELECT COUNT(DISTINCT "blogs"."id") FROM "blogs" LEFT OUTER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
 =&gt; 3
</code></p>

<p>So you need to take caution about iteration on <code>joins</code> query.</p>

<p><code>sh
&gt; Blog.joins(:posts).each do |blog|
&gt;   puts blog.posts.map(&amp;:title).join(', ')
&gt; end
  Blog Load (0.2ms)  SELECT "blogs".* FROM "blogs" INNER JOIN "posts" ON "posts"."blog_id" = "blogs"."id"
  Post Load (0.3ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 1]]
Post 1-1, Post 1-2, Post 1-3, Post 1-4, Post 1-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 1]]
Post 1-1, Post 1-2, Post 1-3, Post 1-4, Post 1-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 1]]
Post 1-1, Post 1-2, Post 1-3, Post 1-4, Post 1-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 1]]
Post 1-1, Post 1-2, Post 1-3, Post 1-4, Post 1-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 1]]
Post 1-1, Post 1-2, Post 1-3, Post 1-4, Post 1-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 2]]
Post 2-1, Post 2-2, Post 2-3, Post 2-4, Post 2-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 2]]
Post 2-1, Post 2-2, Post 2-3, Post 2-4, Post 2-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 2]]
Post 2-1, Post 2-2, Post 2-3, Post 2-4, Post 2-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 2]]
Post 2-1, Post 2-2, Post 2-3, Post 2-4, Post 2-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 2]]
Post 2-1, Post 2-2, Post 2-3, Post 2-4, Post 2-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 3]]
Post 3-1, Post 3-2, Post 3-3, Post 3-4, Post 3-5
  Post Load (0.2ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 3]]
Post 3-1, Post 3-2, Post 3-3, Post 3-4, Post 3-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 3]]
Post 3-1, Post 3-2, Post 3-3, Post 3-4, Post 3-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 3]]
Post 3-1, Post 3-2, Post 3-3, Post 3-4, Post 3-5
  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."blog_id" = ?  [["blog_id", 3]]
Post 3-1, Post 3-2, Post 3-3, Post 3-4, Post 3-5
</code></p>

<hr />

<p><strong>Reference</strong></p>

<ul>
  <li><a href="http://blog.diatomenterprises.com/remove-n1-queries-in-your-ruby-on-rails-app/?utm_source=rubyweekly&amp;utm_medium=email">Remove N+1 queries in your Ruby on Rails app</a></li>
  <li><a href="http://stackoverflow.com/questions/1208636/rails-include-vs-joins?rq=1">Rails :include vs. :joins</a></li>
  <li><a href="http://blog.bigbinary.com/2013/07/01/preload-vs-eager-load-vs-joins-vs-includes.html">Preload, Eagerload, Includes and Joins</a></li>
  <li><a href="http://www.akitaonrails.com/2008/5/26/rolling-with-rails-2-1-the-first-full-tutorial-part-2">Rolling with Rails 2.1 - The First Full Tutorial - Part 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Data Types in Rails]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2015/08/10/data-types-in-rails/"/>
    <updated>2015-08-10T17:45:53+08:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2015/08/10/data-types-in-rails</id>
    <content type="html"><![CDATA[<p><strong><em>Have you ever got annoyed with data types when you are creating Rails migrations?</em></strong></p>

<p><strong><em>What’s the full list of data types in Rails? Does it differ from MySQL to PostgreSQL?</em></strong></p>

<p><strong><em>When adding a <code>title</code> field to <code>Post</code> table, should we use <code>title</code> as a <code>string</code> or <code>text</code>? Same answer with MySQL and PostgreSQL?</em></strong></p>

<p>You may want to check the Rails guides of <a href="http://edgeguides.rubyonrails.org/active_record_migrations.html">Active Record Migrations</a>, but all you get is disappointment because its lacking of essential information about data types.</p>

<p>Here is a quick entry about data types which I extracts from Rails API and Stack Overflow.</p>

<h2 id="general-data-type">General Data Type</h2>

<blockquote>
  <p>From <a href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html#method-i-column">ActiveRecord::ConnectionAdapters::TableDefinition#column</a></p>
</blockquote>

<p>Instantiates a new column for the table. The type parameter is normally one of the migrations native types, which is one of the following: </p>

<ul>
  <li><code>:primary_key</code></li>
  <li><code>:string</code></li>
  <li><code>:text</code></li>
  <li><code>:integer</code></li>
  <li><code>:float</code></li>
  <li><code>:decimal</code></li>
  <li><code>:datetime</code></li>
  <li><code>:time</code></li>
  <li><code>:date</code></li>
  <li><code>:binary</code></li>
  <li><code>:boolean</code></li>
</ul>

<h2 id="specific-dbms-data-type">Specific DBMS Data Type</h2>

<blockquote>
  <p>From Psylone’s answer on <a href="http://stackoverflow.com/a/17279395/1331774">Where is the documentation page for ActiveRecord data types?</a></p>
</blockquote>

<p>Check the specific DB adaptor in source code.</p>

<p><code>ruby MySQL Data Types https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/abstract_mysql_adapter.rb#L244-L256 link
NATIVE_DATABASE_TYPES = {
  :primary_key =&gt; "int(11) auto_increment PRIMARY KEY",
  :string      =&gt; { :name =&gt; "varchar", :limit =&gt; 255 },
  :text        =&gt; { :name =&gt; "text" },
  :integer     =&gt; { :name =&gt; "int", :limit =&gt; 4 },
  :float       =&gt; { :name =&gt; "float" },
  :decimal     =&gt; { :name =&gt; "decimal" },
  :datetime    =&gt; { :name =&gt; "datetime" },
  :time        =&gt; { :name =&gt; "time" },
  :date        =&gt; { :name =&gt; "date" },
  :binary      =&gt; { :name =&gt; "blob" },
  :boolean     =&gt; { :name =&gt; "tinyint", :limit =&gt; 1 }
}
</code></p>

<p><code>ruby PostgreSQL Data Types https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/postgresql_adapter.rb#L77-L112 link
NATIVE_DATABASE_TYPES = {
  primary_key: "serial primary key",
  bigserial: "bigserial",
  string:      { name: "character varying" },
  text:        { name: "text" },
  integer:     { name: "integer" },
  float:       { name: "float" },
  decimal:     { name: "decimal" },
  datetime:    { name: "timestamp" },
  time:        { name: "time" },
  date:        { name: "date" },
  daterange:   { name: "daterange" },
  numrange:    { name: "numrange" },
  tsrange:     { name: "tsrange" },
  tstzrange:   { name: "tstzrange" },
  int4range:   { name: "int4range" },
  int8range:   { name: "int8range" },
  binary:      { name: "bytea" },
  boolean:     { name: "boolean" },
  bigint:      { name: "bigint" },
  xml:         { name: "xml" },
  tsvector:    { name: "tsvector" },
  hstore:      { name: "hstore" },
  inet:        { name: "inet" },
  cidr:        { name: "cidr" },
  macaddr:     { name: "macaddr" },
  uuid:        { name: "uuid" },
  json:        { name: "json" },
  jsonb:       { name: "jsonb" },
  ltree:       { name: "ltree" },
  citext:      { name: "citext" },
  point:       { name: "point" },
  bit:         { name: "bit" },
  bit_varying: { name: "bit varying" },
  money:       { name: "money" },
}
</code></p>

<p>Or, use <code>ActiveRecord::Base.connection.native_database_types.keys</code> to get all valid data types based on your database adaptor.</p>

<p><code>ruby
# PostgreSQL
[1] pry(main)&gt; ActiveRecord::Base.connection.native_database_types.keys
[
  [ 0] :primary_key,
  [ 1] :bigserial,
  [ 2] :string,
  [ 3] :text,
  [ 4] :integer,
  [ 5] :float,
  [ 6] :decimal,
  [ 7] :datetime,
  [ 8] :time,
  [ 9] :date,
  [10] :daterange,
  [11] :numrange,
  [12] :tsrange,
  [13] :tstzrange,
  [14] :int4range,
  [15] :int8range,
  [16] :binary,
  [17] :boolean,
  [18] :bigint,
  [19] :xml,
  [20] :tsvector,
  [21] :hstore,
  [22] :inet,
  [23] :cidr,
  [24] :macaddr,
  [25] :uuid,
  [26] :json,
  [27] :jsonb,
  [28] :ltree,
  [29] :citext,
  [30] :point,
  [31] :bit,
  [32] :bit_varying,
  [33] :money
]
</code></p>

<p>There is another guide about <a href="http://edgeguides.rubyonrails.org/active_record_postgresql.html">Active Record and PostgreSQL</a>.</p>

<blockquote>
  <p>From gotqn’s answer on <a href="http://stackoverflow.com/a/25702629/1331774">Rails 4 datatypes?</a></p>
</blockquote>

<p>Rails data types mapping to different DB data types:</p>

<p><img src="https://github.com/ifyouseewendy/ifyouseewendy.github.io/raw/source/image-repo/data_types_1.png" alt="Data Types 1" />
<img src="https://github.com/ifyouseewendy/ifyouseewendy.github.io/raw/source/image-repo/data_types_2.png" alt="Data Types 2" /></p>

<h2 id="data-type-shortcut-when-generating-model">Data Type Shortcut When Generating Model</h2>

<blockquote>
  <p>From tomascharad’s answer on <a href="http://stackoverflow.com/questions/17918117/rails-4-datatypes">Rails 4 datatypes?</a></p>
</blockquote>

<p>```sh
$ rails generate model -h</p>

<p>Available field types:</p>

<pre><code>Just after the field name you can specify a type like text or boolean.
It will generate the column with the associated SQL type. For instance:

    `rails generate model post title:string body:text`

will generate a title column with a varchar type and a body column with a text
type. If no type is specified the string type will be used by default.
You can use the following types:

    integer
    primary_key
    decimal
    float
    boolean
    binary
    string
    text
    date
    time
    datetime

You can also consider `references` as a kind of type. For instance, if you run:

    `rails generate model photo title:string album:references`

It will generate an `album_id` column. You should generate these kinds of fields when
you will use a `belongs_to` association, for instance. `references` also supports
polymorphism, you can enable polymorphism like this:

    `rails generate model product supplier:references{polymorphic}`

For integer, string, text and binary fields, an integer in curly braces will
be set as the limit:

    `rails generate model user pseudo:string{30}`

For decimal, two integers separated by a comma in curly braces will be used
for precision and scale:

    `rails generate model product 'price:decimal{10,2}'`

You can add a `:uniq` or `:index` suffix for unique or standard indexes
respectively:

    `rails generate model user pseudo:string:uniq`
    `rails generate model user pseudo:string:index`

You can combine any single curly brace option with the index options:

    `rails generate model user username:string{30}:uniq`
    `rails generate model product supplier:references{polymorphic}:index`

If you require a `password_digest` string column for use with
has_secure_password, you should specify `password:digest`:

    `rails generate model user password:digest`
</code></pre>

<p>```</p>

<h2 id="should-you-choose-string-or-text">Should you choose string or text?</h2>

<p>In <strong>MySQL</strong></p>

<blockquote>
  <p>From tjeezy’s answer and Omar Qureshi’s comment on <a href="http://stackoverflow.com/a/3354452/1331774">Difference between string and text in rails?</a></p>
</blockquote>

<p><code>
:string |                   VARCHAR                | :limit =&gt; 1 to 255 (default = 255)
:text   | TINYTEXT, TEXT, MEDIUMTEXT, or LONGTEXT2 | :limit =&gt; 1 to 4294967296 (default = 65536)
</code></p>

<p>So you’d better specify the <code>:limit</code> as a reminder to yourself that there is a limit and you should have a validation in the model to ensure that the limit is not exceeded.</p>

<p>And, you can have indexes on <code>varchars</code>, you cannot on <code>text</code>.</p>

<p>In <strong>Postgresql</strong></p>

<blockquote>
  <p>From PostgreSQL Manual <a href="http://www.postgresql.org/docs/9.3/interactive/datatype-character.html">Character Types</a></p>
</blockquote>

<p>There is no performance difference among these three types, apart from increased storage space when using the blank-padded type, and a few extra CPU cycles to check the length when storing into a length-constrained column. While <code>character(n)</code> has performance advantages in some other database systems, there is no such advantage in PostgreSQL; in fact <code>character(n)</code> is usually the slowest of the three because of its additional storage costs. In most situations <code>text</code> or <code>character</code> varying should be used instead.</p>

<blockquote>
  <p>From Omar Qureshi’s answer on <a href="http://stackoverflow.com/questions/3354330/difference-between-string-and-text-in-rails">Difference between string and text in rails?</a></p>
</blockquote>

<p>If you are using postgres use <code>text</code> wherever you can, unless you have a size constraint since there is no performance penalty for <code>text</code> vs <code>varchar</code>.</p>

<blockquote>
  <p>From mu is too short’s answer on <a href="http://stackoverflow.com/questions/8129776/rails-3-postgres-how-long-is-a-string-if-you-dont-apply-limit-in-schema">rails 3/postgres - how long is a string if you don’t apply :limit in schema</a> and <a href="http://stackoverflow.com/questions/8694273/changing-a-column-type-to-longer-strings-in-rails/8694483#8694483">Changing a column type to longer strings in rails</a></p>
</blockquote>

<p><code>
:string | character varying (255)
:text   | text
</code></p>

<p>There’s no reason to use <code>:string</code> (AKA <code>varchar</code>) at all, the database treats <code>text</code> and <code>varchar(n)</code> the same internally except for the extra length constraints for <code>varchar(n)</code>; you should only use <code>varchar(n)</code> (AKA <code>:string</code>) if you have an external constrain on the column size.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Float Point Arithmetic and Truncation]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2015/04/11/ruby-float-point-arithmetic-and-truncation/"/>
    <updated>2015-04-11T21:17:56+08:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2015/04/11/ruby-float-point-arithmetic-and-truncation</id>
    <content type="html"><![CDATA[<p><strong><em>How to keep precision on float point arithmetic?</em></strong></p>

<p>```ruby
190000 * ( 783.0 / 10000 )
# =&gt; 14876.999999999998</p>

<p>( 190000 * 783.0 ) / 10000
# =&gt; 14877.0
```</p>

<p><strong><em>How to make a 2 point truncation instead of rounding?</em></strong></p>

<p>```ruby
195555 * 0.0783
# =&gt; 15311.956499999998</p>

<p>( 195555 * 0.0783 ).round(2)
# =&gt; 15311.96
```</p>

<h3 id="plain-solution">Plain Solution</h3>

<p>```ruby
# Public: A calculator aims handling Float operation precision and
# saving the result with truncated 2 point Float.
#
# Examples
#
#   190000 * 0.0783
#   # =&gt; 14876.999999999998
#   190000 * 783 / 10000
#   # =&gt; 14877
#
#   cal = RateCalculator.new(190000, 0.0783)
#   cal.run
#   # =&gt; 14877.0
#
#
#   195555 * 0.0783
#   # =&gt; 15311.956499999998
#
#   cal = RateCalculator.new(195555, 0.0783)
#   # =&gt; 15311.95
#
# Returns a Float
class RateCalculator
  attr_reader :base, :rate</p>

<p># Internal: Handles 6 point rate.
  MAGNIFIER = 1000000</p>

<p># Public: Initialization
  #
  # base - Integer
  # rate - Numeric
  def initialize(base, rate)
    raise “#initialize: <base /> needs to be Integer” unless base.is_a? Integer</p>

<pre><code>@base = base
@rate = rate   end
</code></pre>

<p>def run
    truncate_2_point MAGNIFIER<em>rate</em>base/MAGNIFIER
  end</p>

<p>private</p>

<pre><code>def truncate_2_point(float)
  (float * 100).to_i / 100.0
end end ```
</code></pre>

<p>It works, but with so many worries about the unknown conditions.</p>

<h3 id="bigdecimal">BigDecimal</h3>

<p>First, what the hell happens on the precision of float point arithmetic?</p>

<p><code>ruby
0.1 + 0.2
# =&gt; 0.30000000000000004
</code></p>

<p>According to <a href="http://floating-point-gui.de/">What Every Programmer Should Know About Floating-Point Arithmetic</a>, the answer is the binary fraction issue.</p>

<p><img src="https://github.com/ifyouseewendy/ifyouseewendy.github.io/raw/source/image-repo/binary_fraction.png" alt="Binary Fraction" /></p>

<blockquote>
  <p>Specifically, binary can only represent those numbers as a finite fraction where the denominator is a power of 2. Unfortunately, this does not include most of the numbers that can be represented as finite fraction in base 10, like 0.1.</p>
</blockquote>

<p>To get through the precision problem, Ruby provides the <strong>Arbitrary-Precision Decimal</strong> shipped by <code>BigDecimal</code>. And so sweet, <code>BigDecimal</code> supports several rounding modes, including <code>:truncate</code>.</p>

<p>Here is the final solution.</p>

<p>```ruby
require ‘bigdecimal’</p>

<h1 id="public-a-calculator-aims-handling-arithmatic-precision-and">Public: A calculator aims handling arithmatic precision and</h1>
<p># saving the result with 2 points truncated decimal.
#
# Examples
#
#   190000 * 0.0783
#   # =&gt; 14876.999999999998
#   190000 * 783 / 10000
#   # =&gt; 14877
#
#   cal = RateCalculator.new(190000, 0.0783).run
#   # =&gt; 14877.0
#
#
#   195555 * 0.0783
#   # =&gt; 15311.956499999998
#
#   cal = RateCalculator.new(195555, 0.0783).run
#   # =&gt; 15311.95
#
# Returns a BigDecimal
class RateCalculator
  attr_reader :base, :rate</p>

<p>def initialize(base, rate)
    @base = BigDecimal(base.to_s)
    @rate = BigDecimal(rate.to_s)
  end</p>

<p>def run
    BigDecimal.save_rounding_mode do
      BigDecimal.mode(BigDecimal::ROUND_MODE, :truncate)
      (base*rate).round(2)
    end
  end
end</p>

<p>```</p>

<h4 id="reference">Reference</h4>

<ul>
  <li><a href="http://floating-point-gui.de/">Float Point Guide</a></li>
  <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/bigdecimal/rdoc/BigDecimal.html">Ruby Doc BigDecimal</a></li>
  <li><a href="http://makandracards.com/makandra/1178-bigdecimal-arithmetic-in-ruby">BigDecimal arithmetic in Ruby</a></li>
  <li><a href="http://makandracards.com/makandra/1505-invoices-how-to-properly-round-and-calculate-totals">Invoices: How to properly round and calculate totals</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Trick: Local Assignment over Method Sending]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2015/03/30/ruby-trick-local-assignment-over-method-sending/"/>
    <updated>2015-03-30T16:24:59+08:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2015/03/30/ruby-trick-local-assignment-over-method-sending</id>
    <content type="html"><![CDATA[<p>There is a weird situation I haven’t noticed before:</p>

<p>```ruby
class Counter
  attr_accessor :processed, :processed_names</p>

<p>def initialize
    @processed = 0
    @processed_names = []
  end</p>

<p>def foo
    processed += 1
  end</p>

<p>def bar
    processed_names « ‘a’
  end
end</p>

<p>w = Counter.new;
w.foo # =&gt; NoMethodError: undefined method <code>+' for nil:NilClass</code>
w.bar # =&gt; [‘a’]
```</p>

<p><strong><em>Why the hell?</em></strong></p>

<p><strong>Local assignment always has precedence over method sending</strong>. Assignment happened in <code>w.foo</code>, which not in <code>w.bar</code>.</p>

<p>Check this one:</p>

<p>```
class Person
  attr_accessor :name</p>

<p>def foo
    name = ‘John’
  end
end</p>

<p>t = Tao.new
t.name # =&gt; nil
t.foo  # =&gt; ‘John’
t.name # =&gt; nil
```</p>

<p><code>name = 'John'</code> only means a definition of a local variable, which won’t send <code>=</code> to <code>name</code>.</p>
]]></content>
  </entry>
  
</feed>
