<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Wendi's Blog]]></title>
  <link href="http://blog.ifyouseewendy.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://blog.ifyouseewendy.com/"/>
  <updated>2020-06-02T22:56:33-04:00</updated>
  <id>http://blog.ifyouseewendy.com/</id>
  <author>
    <name><![CDATA[wendi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[An Essential Difference Between OOP and FP]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2018/07/01/an-essential-difference-between-oop-and-fp/"/>
    <updated>2018-07-01T23:03:54-04:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2018/07/01/an-essential-difference-between-oop-and-fp</id>
    <content type="html"><![CDATA[<p>A few months ago, I told my friend that I was learning Haskell recently. After giving him
a quick introduction, he asked me an intuitive but hard question that I was not able to give
the answer, ‚ÄúWhat is the difference between OOP and FP?‚Äù.</p>

<p>I thought hard, I asked around and I took it on my way learning Haskell, but apparently there
are no easy answers, considering they usually appear at the opposite position on the spectrum
of programming paradgim.</p>

<p>Anyway, today when I was reviewing my notes for recapping type system in Haskell, the question
got popped up again. But this time, I think I‚Äôve got an answer:</p>

<p>Other than the obvious language characteristics, <strong>the essential difference between OOP and FP
is how they structure values and operations</strong>. OOP groups values and operations together in the
objects, while FP separates values and operations apart strictly.</p>

<p>Seriously, is that an answer? I konw, it‚Äôs not perfect, but definitely helpful to myself. I‚Äôll make
a detailed explanation.</p>

<h2 id="what-is-a-program">What is a program?</h2>

<p>We use programming languages to write programs, which can be considered as a series of calculations
executed in many stacks of control flows. It‚Äôs not hard to figure out that, in essence, a program is
about <strong>operating values</strong>.</p>

<p>As the definition for <em>turing complete</em> says, language is about <em>data-manipulation</em>.</p>

<blockquote>
  <p>In computability theory, a system of data-manipulation rules (such as a computer‚Äôs instruction set,
a programming language, or a cellular automaton) is said to be Turing complete or computationally
universal if it can be used to simulate any Turing machine.</p>
</blockquote>

<h2 id="what-is-a-value">What is a value?</h2>

<p><strong><em>The first question is what are basic values?</em></strong></p>

<p>No matter what language you are using, there must be</p>

<p><code>
1
'c'
True # somehow boolean value can also be considered as a integer
</code></p>

<p><strong><em>But what if I want to represent more compliated values?</em></strong></p>

<p>We use data structures:</p>

<ul>
  <li>List, <code>[1,2,3]</code>, a set of independent values</li>
  <li>Tuple, <code>(1,2,3)</code>, several values compound over each other as one value</li>
  <li>Tree, values structured with a purpose to be manipulated easily</li>
  <li>Dictionary? It seems like a combination for value and algorithm</li>
</ul>

<p><strong><em>Apparently, that‚Äôs not enough for us to carve the real world. What‚Äôs the ultimate way to represent data no matter how complicated it is?</em></strong></p>

<p>It depends on what mechanism a language supports. Here jumps in the discussion for difference between
OOP and FP language, which I‚Äôll take Ruby and Haskell as examples.</p>

<p>In Ruby, we use class to model the real world problem and use objects to hold values, which we also call
it state in OO.</p>

<p>```rb
class Person
  attr_accessor :name, :age
end</p>

<p>person = Person.new(‚ÄúDi‚Äù, 18)
```</p>

<p>As we can see, class defines what pattern of data (<code>name</code> and <code>age</code>) we want to hold.
After initializing, an object will wrap the plain data <code>"Di"</code> and <code>18</code> together as a
whole new value.</p>

<p>In Haskell, we use type to model the real world values and everytime we create a customized type,
there will also come with a data constructor, which holds the values together.</p>

<p>```haskell
data Person = Person String Integer</p>

<p>person = Person ‚ÄúDi‚Äù 18
```</p>

<p>As a summary, no matter how complicated the value is, we can always represent it by
applying this kind of mechanisms the language provides over and over again.</p>

<h2 id="how-to-operate-value">How to operate value?</h2>

<p>By rules, laws, or formulas. In another saying, methods or functions.</p>

<p>In Ruby, we define methods in class definition to empower the object to apply onto its states.</p>

<p>```rb
class Person
  attr_accessor :name, :age</p>

<p>def gets_older; age += 1; end
end</p>

<p>person = Person.new(‚ÄúBart‚Äù, 10)
```</p>

<p>When we call <code>person.gets_older</code>, we‚Äôll alter the <code>age</code> value by incrementing it by one. If we
have a peek into our memory, there will be data blobs like in below. Each object exists as
a bundle of values and operations.</p>

<p><code>haskell
 +-----------------+   +-----------------+   +-----------------+
 |_class_: Person  |   |_class_: Person  |   |_class_: Person  |
 |                 |   |                 |   |                 |
 |name: "Bart"     |   |name: "Lisa"     |   |name: "Maggie"   |
 |age:  10         |   |age:  8          |   |age:  1          |
 |                 |   |                 |   |                 |
 |#gets_older      |   |#gets_older      |   |#gets_older      |
 +-----------------+   +-----------------+   +-----------------+
</code></p>

<p>However, in Haskell, we make use of functions to operate values, with limits put on their types.</p>

<p>```haskell
data Person = Person String Integer
person = Person ‚ÄúBart‚Äù 10</p>

<p>getsOlder :: Person -&gt; Person
getsOlder (Person name age) = Person name (age+1)
```</p>

<p>When we call <code>getsOlder person</code>, we‚Äôll create a new copy of person data with <code>age</code> incremented
by one, conforming to immutability. As a comparison, if we look into our memory, we‚Äôll see what‚Äôs
in below.</p>

<p>```haskell
 +‚Äî‚Äî‚Äî‚Äî‚Äî‚Äì+   +‚Äî‚Äî‚Äî‚Äî‚Äî‚Äì+   +‚Äî‚Äî‚Äî‚Äî‚Äî‚Äì+
 |<em>type</em>: Person   |   |<em>type</em>: Person   |   |<em>type</em>: Person   |
 |                 |   |                 |   |                 |
 |name: ‚ÄúBart‚Äù     |   |name: ‚ÄúLisa‚Äù     |   |name: ‚ÄúMaggie‚Äù   |
 |age:  10         |   |age: 8           |   |age: 1           |
 +‚Äî‚Äî‚Äî‚Äî‚Äî‚Äì+   +‚Äî‚Äî‚Äî‚Äî‚Äî‚Äì+   +‚Äî‚Äî‚Äî‚Äî‚Äî‚Äì+</p>

<p>+‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî+</p>

<p>+‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî+
 |<em>type</em>: Function     |
 |                     |
 |name: getsOlder      |
 |sig: Person -&gt; Person|
 +‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî+
```</p>

<h2 id="wrap-up">Wrap up</h2>

<p>As a conclusion, I think OOP and FP take a different approach to operating values. OOP packs up
values and permitted operations together via objects, wheras FP separates values and operations
apart strictly.</p>

<p><em>PS. How does polymorphism fit in the discussion?</em></p>

<p>We can keep following the imaginary memory snapshot above. In OOP, it‚Äôll work as long as
objects repond to the same method, whereas in Haskell, we can loose the function to allow
more general types passed in.</p>

<p>In Ruby, it‚Äôs about duck typing.</p>

<p>```rb
class Person
  def gets_older; age += 1; end
end</p>

<p>class Duck
  def gets_older; age += 1; end
end</p>

<p>def as_time_goes_by(a_living)
  a_living.gets_older # no matter it‚Äôs a person or a duck
end
```</p>

<p>In Haskell, we use type to represent a set of values and typeclass to enforce rules on what kind
of operations can be applied onto the type (the set of values).</p>

<p>```haskell
data Person = Person String Integer deriving (Show)
data Duck = Duck Integer deriving (Show)</p>

<p>class Living a where
  getsOlder :: a -&gt; a</p>

<p>instance Living Person where
  getsOlder (Person name age) = Person name (age+1)</p>

<p>instance Living Duck where
  getsOlder (Duck age) = Duck (age+1)</p>

<p>asTimeGoesBy :: Living a =&gt; a -&gt; a
asTimeGoesBy living = getsOlder living
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Peep at Types in Haskell]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2018/04/21/a-peep-at-types-in-haskell/"/>
    <updated>2018-04-21T10:15:19-04:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2018/04/21/a-peep-at-types-in-haskell</id>
    <content type="html"><![CDATA[<p>Functional programming is a shining and trending topic on the other side of the spectrum of programming, which has been
proven to be a better choice in some specific area of problem solving. I could still remember the mind blowing of various
ideas and thoughts in FP when I first learnt Elm two years ago. It just shows me yet another possibility of thinking
after being immersed in the world I took for granted, all kinds of the imperative languages, C, Java, Ruby, Javascript.
It‚Äôs a whole new world.</p>

<p>Recently, I picked up the FP learning by taking part in a book reading club in the company I work, for
<a href="http://haskellbook.com/">‚ÄúHaskell Programming from first principles‚Äù</a>. My girlfriend was teasing me that I‚Äôve never
showed up in a Haskell class at the university, why the heck you talk about it all the time now. I should admit that I might
still feel bored if I could jump back in time. It‚Äôs just I don‚Äôt have the mind power or experience to think about the
problem in a big picture at that time. Anyway, I‚Äôm glad it‚Äôs never too late. It‚Äôs been two months for the fun journey.
I want to share some thoughts on it.</p>

<p>I just finished reading about algebraic data types in Haskell. Basically, it‚Äôs done talking about type systems in the
book. By getting to know types in Haskell, I questioned about why type exists all the time. I cannot help myself
thinking about how would I solve the same problem in OO world, like what is the difference about how data is
structured between OO and FP. Gradually, keeping punching my head, I feel like I start to see something through. I start
to realize that, <strong>programming is all about data and operations</strong>. Different paradigms, OO and FP, are two different
approaches. Under the big picture, languages choose to implement different characteristics, like
inheritance, encapsulation, polymorphism, prototype, immutability, static and dynamic types, etc, to reach a same goal,
to represent and manipulate data in an effective way.</p>

<p>Since it‚Äôs all about data, what is data? I consider it as a general name for all possible values, like primitive ones, <code>1, 'a',
True</code>, which are usually bulit into the language, like a list <code>[]</code> and a map <code>{}</code>, working as a group of values following some basic
simple rules. To better fit the language into modeling various realistic problems, OO introduces class, which packs up the states
(data) and methods (operation) together (In some sense, class is a set of data and rules applied onto the data). In the meantime, FP
provides a different path, with type as a representation of a set of data and function (operation) as a way to transform data. For
example, in OO <code>obj</code> has a state <code>value</code>, and <code>obj.foo</code> might migrate the state. In FP, we just do <code>foo(value)</code>
directly. (The limitation or visibility of the operation comes from encapsulation in OO, but type matching in FP)</p>

<p>So what is type? Type, in short, is a set of values (data). For example, <code>Int8</code> is a built-in type in Haskell as a set of 256
numbers, starting from -128 to 127, <code>Char</code> is a set of all possible charaters, <code>String</code> is a list of <code>Char</code>. How
to represent a binary tree:</p>

<p><code>
	  2
  /   \
1      3
</code></p>

<p>What exactly do we need to know about the tree? Three nodes with three values, and the connections among them.</p>

<p>In OO, we are going to create a structure regarding the node, with a state recording the value and two links for the
connection.</p>

<p>```ruby
class Node
  attr_accessor :left, right</p>

<p>def initialize(value)
    @value = value
    left = nil
    right = nil
  end
end</p>

<p>root        = Node.new(2)
root.left   = Node.new(1)
root.right  = Node.new(3)
```</p>

<p>To make it a tree, instead of a plie of nodes, we can create a structure like</p>

<p>```ruby
class BinaryTree
  attr_reader :root_node</p>

<p>def initialize(root_value)
    @root_node = Node.new(root_value)
  end</p>

<p>def insert(node_value)
    ‚Ä¶
  end
end
```</p>

<p>So a final representation for the binary tree in Ruby, it‚Äôll be</p>

<p><code>ruby
bt = BinaryTree.new(2).insert(1).insert(3)
</code></p>

<p>What about in Haskell? At first, we create a type to represent the tree like below, which basically means a binary tree
is either a leaf, or a node with a value and two nodes, which are both binary trees.</p>

<p><code>haskell
data BinaryTree a = Leaf | Node (BinaryTree a) a (BinaryTree a)
</code></p>

<p>To represent the tree,</p>

<p><code>haskell
bt = Node (Node Leaf 2 Leaf) 1 (Node Leaf 3 Leaf)
</code></p>

<p>It‚Äôs done! To be honest, I was totally blown away by the second I understand how things work here. It‚Äôs neat, elegant
and way over my thinking.</p>

<p>Cool, so how it works? Between two cases in two languages. Here is my understanding: in the perspective of a
compiler (or interpreter),</p>

<ul>
  <li>In Ruby, it sees a reference to a chunk of memory, which contains the necessary info about getting to know that, there
is an object, which has a state and maybe a reference to its parent, which contains operations allowed to do.</li>
  <li>In Haskell, it sees a sequence of tokens, literally all the data about it. According to the types definition, it
could parse out the tokens in the right pattern, thus understand it.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/ifyouseewendy/ifyouseewendy.github.io/source/image-repo/binary-tree-oo-and-haskell.png" alt="binary-tree-oo-and-haskell" /></p>

<p>Bascially, this is a note of thinking while I was learning it. I‚Äôm still digesting and trying to find out a path to fit the FP ideas into my system of knowledge.</p>

<p>At last, I want to share some materials which is truly helpful to me</p>

<ul>
  <li><a href="http://www.defmacro.org/2006/06/19/fp.html">Functional Programming For The Rest of Us - Slava Akhmechet</a> Such a pleasant article as a beginner read, the history, the features, everything you need to know</li>
  <li><a href="https://youtu.be/yVuEPwNuCHw">Types, and why you should care - Ron Minsky</a> An intro video about the pros and cons
about types</li>
  <li><a href="https://youtu.be/V1po0BT7kac">Type Systems Will Make You a Better JavaScript Developer - Jared Forsyth</a> A video talking about why Facebook Flow works effectively for JS. I use it at work, but sometimes I stumble upon it and end up complaining about its stupidity. Next time, I‚Äôll watch the video again.</li>
  <li><a href="https://flow.org/en/docs/lang/">Type Systems - Facebook Flow</a> I find it as a good supplyment after getting understand
the types in Haskell, maybe because it is a standalone type system?</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Name Driven Development]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2016/05/26/name-driven-development/"/>
    <updated>2016-05-26T18:53:08+08:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2016/05/26/name-driven-development</id>
    <content type="html"><![CDATA[<blockquote>
  <p>‚ÄúAny fool can write code that a computer can understand. Good programmers write code that humans can understand.‚Äù - Martin Fowler</p>
</blockquote>

<blockquote>
  <p>‚ÄúThere are only two hard things in Computer Science: cache invalidation and naming things.‚Äù ‚Äî Phil Karlton</p>
</blockquote>

<p>‚ÄúName Driven Development‚Äù, this is a ghost topic you can‚Äôt find on wiki. I just use it to remind me how much importance a good name can give. Maybe it‚Äôs just another bad nameüòÇ.</p>

<p>In a nutshell, why naming matters a lot is that it‚Äôs so closely related to refactoring. Here are some basic ideas I conclude</p>

<ul>
  <li>Good name reveals intention, shows legibility, and keeps clarity.</li>
  <li>Keep refactoring, until the name reveals the intention in an easy way.</li>
  <li>Don‚Äôt bother about naming too much when developing. Let the test and implementation help reveal it‚Äôs purpose. Then make a good name.</li>
</ul>

<p>To tackle this non-existing topic, I‚Äôve googled around, reading and thinking. Here are some notes I made (to be updated).</p>

<hr />

<blockquote>
  <p><a href="https://ilinkuo.wordpress.com/2013/05/07/whats-in-a-name/#more-137">What‚Äôs in a Name? - ilinkuo</a></p>
</blockquote>

<p>Your Names Tell a Story about Your Design</p>

<p><img src="https://github.com/ifyouseewendy/ifyouseewendy.github.io/raw/source/image-repo/name-drive-development/your_names_tell_a_story_about_your_design.png" alt="your_names_tell_a_story_about_your_design" /></p>

<blockquote>
  <p><a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code: Chapter 2, ‚ÄúMeaningful Names‚Äù - Uncle Bob</a></p>

  <p>The ‚Äúdefinitive‚Äù guide</p>
</blockquote>

<p><em>Good</em></p>

<p><img src="https://github.com/ifyouseewendy/ifyouseewendy.github.io/raw/source/image-repo/name-drive-development/meaningful_names_basic.png" alt="meaningful_names_basic" /></p>

<p><em>Better</em></p>

<p><img src="https://github.com/ifyouseewendy/ifyouseewendy.github.io/raw/source/image-repo/name-drive-development/meaningful_names_advanced.png" alt="meaningful_names_advanced" /></p>

<blockquote>
  <p><a href="http://arlobelshee.com/good-naming-is-a-process-not-a-single-step/">Good naming is a process, not a single step - Arlo Belshee</a></p>

  <p>This serial posts provide a methodology, which explains the naming process in a clear and specific way. The first four steps aim at how to better name considering implementation, then move to thinking of intent, and domain abstraction.</p>
</blockquote>

<p><img src="https://github.com/ifyouseewendy/ifyouseewendy.github.io/raw/source/image-repo/name-drive-development/good_naming_is_a_process.png" alt="good_naming_is_a_process" /></p>

<h3 id="summary">Summary</h3>

<ul>
  <li>Missing</li>
  <li>Nonsense</li>
  <li>Honest</li>
  <li>Honest and Complete</li>
  <li>Does the Right Thing</li>
  <li>Intent</li>
  <li>Domain Abstraction</li>
</ul>

<h3 id="why">Why</h3>

<p>The answer to that question lies at the heart of understanding, preventing, and paying off technical debt.</p>

<ul>
  <li>Indebted code is any code that is hard to scan.</li>
  <li>Technical debt is anything that increases the difficulty of reading code.</li>
</ul>

<p><em>Shouldn‚Äôt the definition of technical debt be something about the cost and risk of changing code?</em></p>

<p>It turns out that the largest single thing developers <strong>spend time doing is reading code</strong>. More than design, more than writing code, more than scanning, even more than meetings (well, probably).</p>

<p><strong>Bugs come from incomplete understanding</strong>. Incomplete understanding arises when the system is harder to understand than we can store in our heads at once.</p>

<p>So if our definition of technical debt is code that is difficult, expensive, or risky to change, then the root cause of that is code that is hard to scan. And how do we make code easy to scan? Use good names to encapsulate details.</p>

<h3 id="how">How</h3>

<p>If we want to make code more scannable, we need to increase the percentage of relevant information that it screams at you. Which also means hiding the irrelevant information.</p>

<p>The process of reducing debt is simple:</p>

<ul>
  <li>Look at something.</li>
  <li>Have an insight.</li>
  <li>Write it down.
    <ul>
      <li>Ccomment. But <strong>comments</strong> aren‚Äôt actually part of the code. They duplicate the code, which causes all the usual duplication problems.</li>
      <li>If your insight is structural then it belongs in a <strong>name</strong>. If it is a runtime insight then use an <strong>assertion</strong>.</li>
      <li>Assertions need to be easy to find. So don‚Äôt litter them around your core code. Express your insight as an example and write it down in a test. And name the test about the insight (not about what code it happens to execute).</li>
      <li>So, insights belong in names.</li>
    </ul>
  </li>
  <li>Check it in.
    <ul>
      <li>Express your intent by naming your commit using a message.</li>
    </ul>
  </li>
</ul>

<p>The insight loop is all there is</p>

<ul>
  <li>Refactoring legacy code is running this loop and writing stuff down in names.</li>
  <li>Understanding legacy code is running this loop and writing stuff down as examples in tests.</li>
  <li>TDD is running this loop three times:
    <ul>
      <li>First a loop where we look at the customer interview and we write it down as one example in a test.</li>
      <li>Second a loop where we look at the test and we write it down in names in the code.</li>
      <li>Third a loop of refactoring the (new) legacy code.</li>
    </ul>
  </li>
  <li>Design is a loop where the place you look is ‚Äúhow hard was it to write this test‚Äù and you write down insights by changing names (usually fixing the Does the Right Thing step).</li>
</ul>

<h3 id="steps">Steps</h3>

<p>Each transition is about refactoring.</p>

<p><img src="https://github.com/ifyouseewendy/ifyouseewendy.github.io/raw/source/image-repo/name-drive-development/good_naming_is_a_process_table.png" alt="good_naming_is_a_process_table" /></p>

<blockquote>
  <p><a href="https://stackoverflow.com/posts/422093/revisions">krosenvold</a> answer on <a href="https://stackoverflow.com/questions/421965/anyone-else-find-naming-classes-and-methods-one-of-the-most-difficult-part-in-pr/423140#423140">Stack Overflow - Anyone else find naming classes and methods one of the most difficult part in programming?</a></p>
</blockquote>

<p><code>
function programming_job(){
    while (i make classes){
         Give each class a name quickly; always fairly long and descriptive.
         Implement and test each class to see what they really are.
         while (not satisfied){
            Re-visit each class and make small adjustments
         }
    }
}
</code></p>

<blockquote>
  <p><a href="http://programmers.stackexchange.com/users/31260/gnat">gnat</a> answered on <a href="http://programmers.stackexchange.com/questions/129961/are-there-good-techniques-or-tests-for-naming-types">Stack Exchange - Are there good techniques or tests for naming types?</a></p>
</blockquote>

<p>For naming, there are six techniques that were proven to work for me:</p>

<ul>
  <li>spend a lot of time on inventing names</li>
  <li>use code reviews</li>
  <li>don‚Äôt hesitate to rename</li>
  <li>spend a lot of time on inventing names</li>
  <li>use code reviews</li>
  <li>don‚Äôt hesitate to rename</li>
</ul>

<blockquote>
  <p><a href="http://www.gameproducer.net/2008/11/11/the-7-worst-verbs-programmers-use-in-function-calls/">The 7 Worst Verbs Programmers Use In Function Calls - Juuso Hietalahti</a></p>
</blockquote>

<ul>
  <li>dispatch</li>
  <li>do</li>
  <li>resolve</li>
  <li>handle</li>
  <li>manage</li>
  <li>perform</li>
  <li>populate</li>
</ul>

<blockquote>
  <p><a href="http://objology.blogspot.com/2011/09/one-of-best-bits-of-programming-advice.html">One of the Best Bits of Programming Advice I ever Got</a></p>
</blockquote>

<p>Don‚Äôt make objects that end with ‚Äòer‚Äô.</p>

<ul>
  <li>Managers - Every time I see one of these, I cringe. People will usually tell me what it does, long before they can tell me what it is. Is it a registry? Fine call it a registry. Is it a history or a log? Call it that. Is it a factory? Call it that.</li>
  <li>Controllers - Only good controller object I‚Äôve made in the last 20 years was an interface to a BallastVoltageController that represented a real world object. The fact that every single MVC implementation in the world has had a different role for Controller ought to tell us something about how well that idea fit.</li>
  <li>Organizer (and many like them) - Focus is on what it does. This is a great example of how easy it is to turn many of these ‚Äòers‚Äô into nouns. Call it an Organization. Now we‚Äôre focusing on what it is.</li>
  <li>Analyzer/Renderer/etc - Definitely examples of ‚Äúworker‚Äù objects. What if they had been Analysis/Rendering/etc.</li>
  <li>Builder/Loader/Reader/Writer/etc - Remove the focus from the objects being manipulated, and tend assume to much responsibility themselves.</li>
</ul>

<blockquote>
  <p><a href="http://www.carlopescio.com/2011/04/your-coding-conventions-are-hurting-you.html">Your coding conventions are hurting you - Carlo Pescio</a></p>

  <p>Great article explaining four harmful conventions with obvious examples. There is a following post, <a href="http://www.carlopescio.com/2012/03/life-without-controller-case-1.html">Life without a controller</a></p>
</blockquote>

<p>From a distance, everything is object oriented, extra-cool, modern-flexible-etc, but as you get closer, you realize it‚Äôs just a thin veneer over procedural thinking (and don‚Äôt even get me started about being ‚Äúmodern‚Äù).</p>

<p>Fake OO names and harmful conventions</p>

<ul>
  <li>the -er suffix</li>
  <li>the -able suffix</li>
  <li>the -Object suffix</li>
  <li>the I- prefix</li>
</ul>

<p><strong>Manager, Helper, Handler‚Ä¶</strong></p>

<p>Good ol‚Äô Peter Coad used to say: Challenge any class name that ends in ‚Äú-er‚Äù (e.g. Manager or Controller). If it has no parts, change the name of the class to what each object is managing. If it has parts, put as much work in the parts that the parts know enough to do themselves (that was the ‚Äú<strong>er-er Principle</strong>‚Äù).</p>

<ul>
  <li>Manager. When you need a Manager, it‚Äôs often a sign that the Managed are just plain old data structures, and that the Manager is the smart procedure doing the real work.</li>
  <li>Handler, again, is an obvious resurrection of procedural thinking. What is an handler if not a damn procedure?</li>
</ul>

<p><strong>Something-able</strong></p>

<p>It‚Äôs like calling a nail ‚ÄúHammerable‚Äù, because you known, that‚Äôs what you do with a nail, you hammer it. It encourages procedural thinking, and leads to ineffective abstractions.</p>

<p><strong>Something-Object</strong></p>

<p>When you don‚Äôt know how to name something, pick some dominant trait and add Object to the end. Again, the problem is that the ‚Äúdominant trait‚Äù is moving us away from the concept of an object. Object is dropped in just to avoid more careful thinking about the underlying concept.</p>

<p><strong>ISomething</strong></p>

<p>The problem is that it‚Äôs too easy to fall into the trap, and just take a concrete class name, put an I in front of it, and lo and behold!, you got an interface name. Sort of calling a concept IDollar instead of Currency.</p>

<p>Eg.</p>

<ul>
  <li>IList to RandomAccessContainer</li>
  <li>IEnumerable to Sequence.
    <ul>
      <li>A List is an IEnumerable (what??)</li>
      <li>A List is a Sequence (well, all right!)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>How to Name Things: the solution to the hardest problem in programming - Peter Hilton <a href="https://skillsmatter.com/skillscasts/5747-how-to-name-things-the-solution-to-the-hardest-problem-in-programming">video</a>, <a href="http://www.slideshare.net/pirhilton/how-to-name-things-the-hardest-problem-in-programming">slide</a></p>

  <p>Taking advice from writers, funny quotes, like Stephen King on refactoring, Hemingway on modelling with personas, .etc.</p>
</blockquote>

<p>Remember: ‚Äúrename‚Äù is the simplest but most effective refactoring. Use it.</p>

<p><strong>Gater domain-specific vocabulary</strong>. Scan the domain model entities Wikipedia pages for names of related concepts. Read novels set in your customer‚Äôs domain to learn their jargon. Find out what they really mean.</p>

<p>Comments: the basics</p>

<ul>
  <li>Don‚Äôt say what the code does (because the code already says that)</li>
  <li>Don‚Äôt explain awkward logic (improve the code to make it clear)</li>
  <li>Don‚Äôt add too many comments (it‚Äôs messy and they‚Äôll get out of date)</li>
  <li>Explain why the code exists
    <ul>
      <li>When should I use this code?</li>
      <li>When shouldn‚Äôt I use it?</li>
      <li>What are the alternatives to this code?</li>
    </ul>
  </li>
</ul>

<p>How to write good comments</p>

<ul>
  <li>Try to write good code first</li>
  <li>Try to write a one-sentence comment</li>
  <li>Refactor the code until the comment is easy to write</li>
  <li>Now write a good comment</li>
  <li>Don‚Äôt forget the rules of good writing. (eg. remove unnecessary comments)</li>
</ul>

<p>P.S. Peter also has several posts talking about commenting, check <a href="http://hilton.org.uk/blog/how-to-comment-code">How to comment code</a></p>

]]></content>
  </entry>
  
</feed>
