<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Excerpts | Wendi's Notes]]></title>
  <link href="http://ifyouseewendy.github.io/blog/categories/excerpts/atom.xml" rel="self"/>
  <link href="http://ifyouseewendy.github.io/"/>
  <updated>2014-09-23T20:22:24+08:00</updated>
  <id>http://ifyouseewendy.github.io/</id>
  <author>
    <name><![CDATA[Wendi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Metaprogramming Ruby]]></title>
    <link href="http://ifyouseewendy.github.io/blog/2014/06/03/metaprogrammingi-ruby/"/>
    <updated>2014-06-03T00:44:28+08:00</updated>
    <id>http://ifyouseewendy.github.io/blog/2014/06/03/metaprogrammingi-ruby</id>
    <content type="html"><![CDATA[<h1>The Object Model</h1>

<p><img src="https://dl.dropboxusercontent.com/s/a6qc1yd1cd57pkp/the_object_model.png?dl=1&amp;token_hash=AAEBXb4OJ73P3xWWbPmIMOferP8_YHxQlS9d8l0hjEq2wQ&amp;expiry=1400078501" alt="the_object_model"></p>

<p>An object contains its instance variables and a reference to a class.</p>

<h2>Instance variable</h2>

<p>Instance variables just spring into existence when you assign them a value, so you can have objects of the same class that carry different instance variables.</p>

<h2>Instance method</h2>

<p>You can get a list of an object’s methods by calling <code>Object#methods</code>.</p>

<p>When you talk about the class, you call it an instance method, and when you talk about the object, you simply call it a method.</p>
<div class="highlight"><pre><code class="ruby"><span class="nb">String</span><span class="o">.</span><span class="n">instance_methods</span> <span class="o">==</span> <span class="s2">&quot;abc&quot;</span><span class="o">.</span><span class="n">methods</span> <span class="c1"># =&gt; true</span>
<span class="nb">String</span><span class="o">.</span><span class="n">methods</span> <span class="o">==</span> <span class="s2">&quot;abc&quot;</span><span class="o">.</span><span class="n">methods</span> <span class="c1"># =&gt; false</span>
</code></pre></div>
<p>An object’s instance variables live in the object itself, and an object’s methods live in the object’s class. That’s why objects of the same class share methods but don’t share instance variables.</p>

<h2>Truth about classes</h2>

<p>The truth about classes: classes themselves are nothing but objects.</p>

<p>The methods of an object are also the instance methods of its class. In turn, this means that the methods of a class are the instance methods of <code>Class</code>:</p>
<div class="highlight"><pre><code class="ruby"><span class="no">Class</span><span class="o">.</span><span class="n">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="c1"># =&gt; [:allocate, :new, :superclass]</span>
</code></pre></div>
<p><strong><em>What&#39;s the difference between <code>class</code> and <code>superclass</code>?</em></strong></p>

<ul>
<li><code>class</code> is about the type which an object belongs to.</li>
<li><code>superclass</code> is about inheritance, between classes.</li>
</ul>

<p>The <code>superclass</code> of Class is Module—which is to say, every class is also a module. To be precise, a class is a module with three additional instance methods (new, allocate, and superclass) that allow you to create objects or arrange classes into hierarchies.</p>

<p><strong><em>Which to pick between Class and Module?</em></strong></p>

<p>Usually, you pick a module when you mean it to be included somewhere, and you pick a class when you mean it to be instantiated or inherited.</p>

<p><strong><em>What&#39;s an Object, and what&#39;s a Class?</em></strong></p>

<ul>
<li><p>What’s an object? It’s a bunch of instance variables, plus a link to a class. The object’s methods don’t live in the object—they live in the object’s class, where they’re called the instance methods of the class.</p></li>
<li><p>What’s a class? It’s an object (an instance of Class), plus a list of instance methods and a link to a superclass. Class is a subclass of Module, so a class is also a module.</p></li>
</ul>

<p><strong><em>What&#39;s the difference between <code>load</code> and <code>require</code>?</em></strong></p>

<p>You use load to execute code, and you use require to import libraries.</p>

<ol>
<li>use <code>require</code>, no need to appends &#39;.rb&#39;.</li>
<li><code>require</code> loads only once.</li>
</ol>

<p><strong><em>As <code>load</code> executes codes, how does <code>load</code> avoid conlicts?</em></strong></p>

<p><code>load(&#39;motd.rb&#39;, true)</code></p>

<p>If you load a file this way, Ruby creates an anonymous module, uses that module as a Namespace to contain all the constants from motd.rb, and then destroys the module.</p>

<h2>Constant</h2>

<p>classes are nothing but objects, class names are nothing but constants.</p>

<p><strong><em>How is a constant really different from a variable?</em></strong></p>

<p>The one important difference has to do with their scope.</p>

<p>Constants are arranged in a tree similar to a file system, where the names of modules and classes play the part of directories and regular constants play the part of files.</p>

<h2>Method lookup</h2>

<p><strong><em>What does Ruby do, when you call a method?</em></strong></p>

<ol>
<li>It finds the method. This is a process called method lookup.</li>
<li>It executes the method. To do that, Ruby needs something called <code>self</code>.</li>
</ol>

<p><strong><em>How does Ruby lookup methods?</em></strong></p>

<p><em>“one step to the right, then up”</em> rule: go one step to the right into the receiver’s class, and then go up the ancestors chain until you find the method.</p>

<p><strong><em>What does ancestor chain look like, when <code>prepend</code> or <code>include</code> multiple modules?</em></strong></p>

<p>The <code>prepend</code> method. It works like <code>include</code>, but it inserts the module below the including class.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">C</span>
  <span class="kp">include</span> <span class="no">M1</span>
  <span class="kp">include</span> <span class="no">M2</span>

  <span class="n">prepend</span> <span class="no">M3</span>
  <span class="n">prepend</span> <span class="no">M4</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">D</span> <span class="o">&lt;</span> <span class="n">C</span><span class="p">;</span> <span class="k">end</span>

<span class="n">D</span><span class="o">.</span><span class="n">ancestors</span> <span class="c1"># =&gt; [&#39;M4&#39;, &#39;M3&#39;, &#39;C&#39;, &#39;M2&#39;, &#39;M1&#39;]</span>
</code></pre></div>
<p><strong><em>What does Ruby do, when <code>prepend</code> or <code>include</code> a module multiple times?</em></strong></p>

<p>If that module is already in the chain, Ruby silently ignores the second inclusion. As a result, a module can only appear once in the same chain of ancestors.</p>

<p><strong>Basic ancestor chain</strong></p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">MyClass</span><span class="p">;</span> <span class="k">end</span>
<span class="no">MyClass</span><span class="o">.</span><span class="n">ancestors</span> <span class="c1"># =&gt; [MyClass, Object, Kernel, BasicObject]</span>
</code></pre></div>
<p><strong><em>What <code>private</code> really means?</em></strong></p>

<p><code>private</code> methods come from two rules working together:</p>

<ol>
<li>you need an explicit receiver to call a method on an object that is not yourself.</li>
<li><code>private</code> methods can be called only with an <strong>implicit <code>self</code></strong>.</li>
</ol>

<p>Put these two rules together, and you’ll see that you can only call a <code>private</code> method on yourself. You can call this the “private rule.“</p>

<p><strong><em>What&#39;s the env when you start the <code>irb</code>?</em></strong></p>

<p>As soon as you start a Ruby program, you’re sitting within an object named <code>main</code> that the Ruby interpreter created for you.</p>

<h2>Refinement</h2>

<p>Refinements are similar to Monkeypatches, but they’re not global. A Refinement is only active in two places:</p>

<ul>
<li>The <code>refine</code> block itself.</li>
<li>The code starting from the place where you call <code>using</code> until the end of the module definition (if you’re in a module definition) or the end of the file (if you’re at the top level).</li>
</ul>

<p><strong><em>Which has the precedence, Refinement or Method lookup?</em></strong></p>

<p>Refinements are like pieces of code patched right over a class, and they override normal method lookup. On the other hand, a Refinement works in a limited area of the program: the lines of code between the call to <code>using</code> and the end of the file, or the end of the module definition.</p>

<p>Code in an active Refinement takes precedence over code in the refined class, and also over code in modules that are included or prepended by the class. Refining a class is like slapping a patch right onto the original code of the class.</p>

<p>A trivia example about Refinement:</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">MyClass</span>

  <span class="k">def</span> <span class="nf">my_method</span>
    <span class="s2">&quot;original my_method()&quot;</span>
  <span class="k">end</span>


  <span class="k">def</span> <span class="nf">another_method</span>
    <span class="n">my_method</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="k">module</span> <span class="nn">MyClassRefinement</span>
  <span class="n">refine</span> <span class="no">MyClass</span> <span class="k">do</span>
    <span class="k">def</span> <span class="nf">my_method</span>
      <span class="s2">&quot;refined my_method()&quot;</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">using</span> <span class="no">MyClassRefinement</span>
<span class="no">MyClass</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">my_method</span>     <span class="c1"># =&gt; &quot;refine my_method()&quot;</span>
<span class="no">MyClass</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">another_method</span> <span class="c1"># =&gt; &quot;original my_method()&quot;</span>
</code></pre></div>
<p>Even if you call <code>another_method</code> after the <code>using</code>, the call to <code>my_method</code> itself happens before the <code>using</code>—so it calls the original, unrefined version of the method.</p>

<p>A help reference, <a href="http://timelessrepo.com/refinements-in-ruby">Refinements in Ruby</a> by The timeless repository.</p>

<h1>Methods</h1>

<h2>Dynamic Dispatch</h2>

<p>Why would you use <code>send</code> instead of the plain old dot notation? Because with <code>send</code>, the name of the method that you want to call becomes just a regular argument. You can wait literally until the very last moment to decide which method to call, while the code is running. This technique is called Dynamic Dispatch.</p>

<p><strong>An example of Dynamic Dispatch</strong></p>

<p>```ruby gems/pry-0.9.12.2/lib/pry/pry<em>instance.rb
def refresh(options={})
  defaults = {}
  attributes = [
          :input, :output, :commands, :print, :quiet,
          :exception</em>handler, :hooks, :custom<em>completions,
          :prompt, :memory</em>size, :extra<em>sticky</em>locals</p>
<div class="highlight"><pre><code class="text">    ]
</code></pre></div>
<p>attributes.each do |attribute|
    defaults[attribute] = Pry.send attribute
  end</p>

<p># ...</p>

<p>defaults.merge!(options).each do |key, value|
    send(&quot;#{key}=&quot;, value) if respond_to?(&quot;#{key}=&quot;)
  end</p>

<p>true
end
```</p>

<p><strong><em>What&#39;s the concern about <code>send</code>?</em></strong></p>

<p>You can call any method with <code>send</code>, including private methods.</p>

<p>You can use <code>public_send</code> instead. It’s like send, but it makes a point of respecting the receiver’s privacy.</p>

<h2>Dynamic Method</h2>

<p>There is one important reason to use <code>Module#define_method</code>(<strong>private</strong>) over the more familiar def keyword: <code>define_method</code> allows you to decide the name of the defined method at runtime.</p>

<h2>Ghost Method</h2>

<p><code>BasicObject#method_missing</code> (<strong>private</strong>)</p>

<p>Ghost Methods are usually icing on the cake, but some objects actually rely almost exclusively on them. They collect method calls through <code>method_missing</code> and forward them to the wrapped object.</p>

<p><strong><em>How can <code>respond_to?</code> missing methods?</em></strong></p>

<p>refernced from <a href="http://blog.marc-andre.ca/2010/11/15/methodmissing-politely/">Method_missing, Politely</a> by Marc Andre.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">StereoPlayer</span>
  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">method</span><span class="o">.</span><span class="n">to_s</span> <span class="o">=~</span> <span class="sr">/play_(\w+)/</span>
      <span class="nb">puts</span> <span class="s2">&quot;Here&#39;s </span><span class="si">#{</span><span class="vg">$1</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span>
      <span class="k">super</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="o">=</span> <span class="no">StereoPlayer</span><span class="o">.</span><span class="n">new</span>
<span class="c1"># ok:</span>
<span class="nb">p</span><span class="o">.</span><span class="n">play_some_Beethoven</span> <span class="c1"># =&gt; &quot;Here&#39;s some_Beethoven&quot;</span>
<span class="c1"># not very polite:</span>
<span class="nb">p</span><span class="o">.</span><span class="n">respond_to?</span> <span class="ss">:play_some_Beethoven</span> <span class="c1"># =&gt; false</span>

<span class="k">class</span> <span class="nc">StereoPlayer</span>
  <span class="c1"># def method_missing ...</span>
  <span class="c1">#   ...</span>
  <span class="c1"># end</span>

  <span class="k">def</span> <span class="nf">respond_to?</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span>
    <span class="nb">method</span><span class="o">.</span><span class="n">to_s</span> <span class="o">=~</span> <span class="sr">/play_(\w+)/</span> <span class="o">||</span> <span class="k">super</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="nb">p</span><span class="o">.</span><span class="n">respond_to?</span> <span class="ss">:play_some_Beethoven</span> <span class="c1"># =&gt; true</span>
</code></pre></div>
<p>You can specialize <code>respond_to?</code>, but it doesnot make a missing method behaves exactly like a method.</p>
<div class="highlight"><pre><code class="ruby"><span class="nb">p</span><span class="o">.</span><span class="n">method</span> <span class="ss">:play_some_Beethoven</span>
<span class="c1"># =&gt; NameError: undefined method `play_some_Beethoven&#39;</span>
<span class="c1">#               for class `StereoPlayer&#39;</span>
</code></pre></div>
<p>Ruby 1.9.2 introduces <code>respond_to_missing?</code> that provides for a clean solution to the problem. Instead of specializing <code>respond_to?</code> one specializes <code>respond_to_missing?</code>.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">StereoPlayer</span>
  <span class="c1"># def method_missing ...</span>
  <span class="c1">#   ...</span>
  <span class="c1"># end</span>

  <span class="k">def</span> <span class="nf">respond_to_missing?</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span>
    <span class="nb">method</span> <span class="o">=~</span> <span class="sr">/play_(\w+)/</span> <span class="o">||</span> <span class="k">super</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="o">=</span> <span class="no">StereoPlayer</span><span class="o">.</span><span class="n">new</span>
<span class="nb">p</span><span class="o">.</span><span class="n">play_some_Beethoven</span> <span class="c1"># =&gt; &quot;Here&#39;s some_Beethoven&quot;</span>
<span class="nb">p</span><span class="o">.</span><span class="n">respond_to?</span> <span class="ss">:play_some_Beethoven</span> <span class="c1"># =&gt; true</span>
<span class="n">m</span> <span class="o">=</span> <span class="nb">p</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="ss">:play_some_Beethoven</span><span class="p">)</span> <span class="c1"># =&gt; #&lt;Method: StereoPlayer#play_some_Beethoven&gt;</span>
<span class="c1"># m acts like any other method:</span>
<span class="n">m</span><span class="o">.</span><span class="n">call</span> <span class="c1"># =&gt; &quot;Here&#39;s some_Beethoven&quot;</span>
<span class="n">m</span> <span class="o">==</span> <span class="nb">p</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="ss">:play_some_Beethoven</span><span class="p">)</span> <span class="c1"># =&gt; true</span>
<span class="n">m</span><span class="o">.</span><span class="n">name</span> <span class="c1"># =&gt; :play_some_Beethoven</span>
<span class="no">StereoPlayer</span><span class="o">.</span><span class="n">send</span> <span class="ss">:define_method</span><span class="p">,</span> <span class="ss">:ludwig</span><span class="p">,</span> <span class="n">m</span>
<span class="nb">p</span><span class="o">.</span><span class="n">ludwig</span> <span class="c1"># =&gt; &quot;Here&#39;s some_Beethoven&quot;</span>
</code></pre></div>
<p><strong><em>What about the constant missing?</em></strong></p>

<p><code>Module#const_missing</code>(<strong>public</strong>)</p>

<p><strong><em>What&#39;s the concern about <code>method_missing</code>?</em></strong></p>

<p>This is a common problem with Ghost Methods: since unknown calls become calls to <code>method_missing</code>, your object might accept a call that’s just plain wrong. Finding a bug like this one in a large program can be pretty painful.
To avoid this kind of trouble, take care not to introduce too many Ghost Methods.</p>

<p>Ghost Methods can be dangerous. You can avoid most of their problems by following a few basic recommendations (always call <code>super</code>, always redefine <code>respond_to_missing?</code>)</p>

<p>And you may call some methods <code>Object</code> or some others classes in ancestor chain defined.</p>

<p><strong><em>How to solve it? Blank Slate!</em></strong></p>

<p>Remove methods from an object to turn them into Ghost Methods.</p>

<ul>
<li>Inheriting from <code>BasicObject</code> is the quicker way to define a Blank Slate in Ruby.</li>
</ul>
<div class="highlight"><pre><code class="ruby"><span class="n">im</span> <span class="o">=</span> <span class="no">BasicObject</span><span class="o">.</span><span class="n">instance_methods</span>
<span class="n">im</span> <span class="c1"># =&gt; [:==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__]</span>
</code></pre></div>
<ul>
<li>Inheriting from <code>Object</code> by default, and remove method inherited.</li>
</ul>

<p>Don&#39;t hide <code>instance_eval</code> or any method beginning with <code>__</code>. One example of a reserved method is <code>BasicObject#__send__</code>, that behaves the same as send, but gives you a scary warning when you try to remove it.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">Compter</span>
  <span class="nb">instance_methods</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
    <span class="n">undef_method</span> <span class="n">m</span> <span class="k">unless</span> <span class="n">m</span><span class="o">.</span><span class="n">to_s</span> <span class="o">=~</span> <span class="sr">/^__|method_missing|respond_to/</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<ul>
<li>Or you can write a BlankSlate class to inherit.</li>
</ul>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">BlankSlate</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">hide</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">unless</span> <span class="nb">instance_methods</span><span class="o">.</span><span class="n">include?</span> <span class="nb">name</span><span class="o">.</span><span class="n">to_s</span>
    <span class="k">return</span> <span class="k">if</span> <span class="nb">name</span><span class="o">.</span><span class="n">to_s</span> <span class="o">=~</span> <span class="sr">/^__|method_missing|respond_to/</span>
    <span class="vi">@hidden_methods</span> <span class="o">||=</span> <span class="p">{}</span>
    <span class="vi">@hidden_methods</span><span class="o">[</span><span class="nb">name</span><span class="o">.</span><span class="n">to_sym</span><span class="o">]</span> <span class="o">=</span> <span class="nb">instance_method</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="n">undef_method</span> <span class="nb">name</span>
  <span class="k">end</span>

  <span class="nb">instance_methods</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">hide</span> <span class="n">m</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div>
<p><strong><em>What&#39;s the difference between <code>undef_method</code> and <code>remove_method</code>?</em></strong></p>

<ul>
<li>The drastic <code>undef_method</code> removes any method, including the inherited ones.</li>
<li>The kinder <code>remove_method</code> removes the method from the receiver, but it leaves inherited methods alone.</li>
</ul>

<p><strong><em>What&#39;s the boiling down facts between Ghost Method and really methods?</em></strong></p>

<p>Ghost Method are just a way to intercept method calls. Because of this fact, they behave different than actual methods.</p>

<p><strong><em>What&#39;s the choice between <code>define_method</code> and <code>method_missing</code>?</em></strong></p>

<p>There are times when Ghost Methods are your only viable option. This usually happens</p>

<ul>
<li>When you have a large number of method calls.</li>
<li>When you don’t know what method calls you might need at runtime.</li>
</ul>

<p><em>Use Dynamic Methods if you can, and Ghost Methods if you have to.</em></p>

<h1>Callables</h1>

<h2>the Callables</h2>

<blockquote>
<p>Package code, and call it later</p>
</blockquote>

<ul>
<li><strong>block</strong>, evaluated in the scope which they&#39;re defined.</li>
<li><strong>proc</strong>, which is basically a block turned object, and evaluated in the scope which they&#39;re defined.</li>
<li><strong>lambda</strong>, which is a slight variation on a proc.</li>
<li><strong>method</strong>, bound to an object, which are evaluated in that object’s scope. They can also be unbound from their scope and rebound to another object or class.</li>
</ul>

<p><strong>block</strong> is not an object, while <strong>proc</strong> and <strong>lambda</strong> are Proc objects, and <strong>method</strong> is <a href="http://stackoverflow.com/questions/2602340/methods-in-ruby-objects-or-not">in question</a>.</p>

<h2>Blocks</h2>

<p>The main point about blocks is that they are all inclusive and come ready to run. They contain both the <strong>code</strong> and <strong>a set of bindings</strong>.</p>

<p><strong>When you define the block, it simply grabs the bindings that are there at that moment</strong>, and then it carries those bindings along when you pass the block into a method.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">my_method</span>
  <span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;Goodbye&quot;</span>
  <span class="k">yield</span><span class="p">(</span><span class="s2">&quot;cruel&quot;</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;Hello&quot;</span>
<span class="n">my_method</span> <span class="p">{</span><span class="o">|</span><span class="n">y</span><span class="o">|</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">, </span><span class="si">#{</span><span class="n">y</span><span class="si">}</span><span class="s2"> world&quot;</span> <span class="p">}</span> <span class="c1"># =&gt; &quot;Hello, cruel world&quot;</span>
</code></pre></div>
<p><strong><em>What if I define additional bindings inside a block?</em></strong></p>

<p>They disappear after the block ends.</p>

<p><strong><em>What&#39;s the meaning of &quot;a block is a closure&quot;?</em></strong></p>

<p>a block is a closure, this means a block captures the local bindings and carries them along with it.</p>

<p><strong>scope</strong></p>

<p>You can see bindings all over the scope.</p>

<p><code>class</code>, <code>module</code>, and <code>def</code>, respectively. Each of these keywords acts like a <strong>Scope Gate</strong>.</p>

<p><strong>A subtle difference between <code>class</code>, <code>module</code> and <code>def</code></strong></p>

<p>The code in a <code>class</code> or <code>module</code> definition is executed immediately. Conversely, the code in a method definition is executed later, when you eventually call the method.</p>

<p><strong><em>Whenever the program changes scope, some bindings are replaced by a new set of bindings. RIGHT?</em></strong></p>

<p>For <code>local_varialbes</code>, that&#39;s right, but <code>instance_variables</code>, <code>class_variables</code> and <code>global_variables</code> can go through the Scope Gate.</p>

<p><strong><em>What&#39;s the difference between Global Variables and Top-Level Instance Variables?</em></strong></p>

<p>when it comes to global variables, use them sparingly, if ever.</p>

<p>You can access a top-level instance variable whenever <code>main</code> takes the role of self. When any other object is <code>self</code>, the top-level instance variable is out of scope.</p>

<p><strong><em>How to cross the Scope Gate, and Why?</em></strong></p>

<p>You can use these techniques:</p>

<ul>
<li>Use Flat Scope (<code>Class.new</code>, <code>Module.new</code>, and <code>define_method</code>)</li>
<li>Use Shared Scope</li>
<li>Use Context Probe (<code>BasicObject#instance_eval</code>)</li>
</ul>

<p>to mix code and bindings at will.</p>

<p><strong><em>What is Flat Scope?</em></strong></p>

<p>“flattening the scope,” meaning that the two scopes share variables as if the scopes were squeezed together. For short, you can call this spell a Flat Scope.</p>

<p>Use <code>Class.new</code>, <code>Module.new</code> and <code>define_method</code>.</p>

<p><strong><em>What is Shared Scope?</em></strong></p>
<div class="highlight"><pre><code class="ruby"><span class="c1"># use `def` to do seperate</span>
<span class="k">def</span> <span class="nf">define_methods</span>
  <span class="n">shared</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="no">Kernel</span><span class="o">.</span><span class="n">send</span> <span class="ss">:define_method</span><span class="p">,</span> <span class="ss">:counter</span> <span class="k">do</span>
    <span class="n">shared</span>
  <span class="k">end</span>

  <span class="no">Kernel</span><span class="o">.</span><span class="n">send</span> <span class="ss">:define_method</span><span class="p">,</span> <span class="ss">:inc</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
    <span class="n">shared</span> <span class="o">+=</span> <span class="n">x</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">define_methods</span>


<span class="n">counter</span> <span class="c1"># =&gt; 0</span>
<span class="n">inc</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">counter</span> <span class="c1"># =&gt; 4</span>
</code></pre></div>
<p>If you define multiple methods in the same Flat Scope, maybe protected by a Scope Gate, all those methods can share bindings. That’s called a <strong>Shared Scope</strong></p>

<p><strong><em>What is Context Probe?</em></strong></p>

<p><code>instance_eval</code> has a slightly more flexible twin brother named <code>instance_exec</code>, that allows you to pass arguments to the block.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">C</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@x</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">D</span>
  <span class="k">def</span> <span class="nf">twisted_method</span>
    <span class="vi">@y</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">C</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">instance_eval</span> <span class="p">{</span> <span class="s2">&quot;@x: </span><span class="si">#{</span><span class="vi">@x</span><span class="si">}</span><span class="s2">, @y: </span><span class="si">#{</span><span class="vi">@y</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">D</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">twisted_method</span> <span class="c1"># =&gt; &quot;@x: 1, @y: &quot;</span>
</code></pre></div>
<p>However, instance variables depend on <code>self</code>, so when <code>instance_eval</code> switches <code>self</code> to the receiver, all the instance variables in the caller fall out of scope.</p>

<p><strong>Clean Room</strong></p>

<p>Blank Slates are good candidates for Clean Room.</p>

<p>The ideal Clean Room doesn’t have many methods or instance variables, because the names of those methods and instance variables could clash with the names in the environment that the block comes from. For this reason, instances of <code>BasicObject</code> usually make for good Clean Rooms, because they’re Blank Slates.</p>

<p>You might think of using a <code>BasicObject</code> instead of an Object for your Clean Room. However, remember that <code>BasicObject</code> is also a Blank Slate, and as such it lacks some common methods such as puts.</p>

<p><strong><em>What&#39;s the different use for Shared Scope and Clean Room?</em></strong></p>

<p><em>Shared Scope</em> is used in definition, to make variables(bindings) shared between methods, while <em>Clean Room</em> is used to run code, to help reduce the modifications on shared variables(like instance variables).</p>
<div class="highlight"><pre><code class="ruby"><span class="c1"># lambda which is called immediatley is the Shared Scope</span>
<span class="nb">lambda</span> <span class="p">{</span>
  <span class="n">setups</span> <span class="o">=</span> <span class="o">[]</span>
  <span class="n">events</span> <span class="o">=</span> <span class="o">[]</span>

  <span class="no">Kernel</span><span class="o">.</span><span class="n">send</span> <span class="ss">:define_method</span><span class="p">,</span> <span class="ss">:event</span> <span class="k">do</span> <span class="o">|</span><span class="n">description</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">|</span>
    <span class="n">events</span> <span class="o">&lt;&lt;</span> <span class="p">{</span><span class="ss">:description</span> <span class="o">=&gt;</span> <span class="n">description</span><span class="p">,</span> <span class="ss">:condition</span> <span class="o">=&gt;</span> <span class="n">block</span><span class="p">}</span>
  <span class="k">end</span>

  <span class="no">Kernel</span><span class="o">.</span><span class="n">send</span> <span class="ss">:define_method</span><span class="p">,</span> <span class="ss">:setup</span> <span class="k">do</span> <span class="o">|&amp;</span><span class="n">block</span><span class="o">|</span>
    <span class="n">setups</span> <span class="o">&lt;&lt;</span> <span class="n">block</span>
  <span class="k">end</span>

  <span class="no">Kernel</span><span class="o">.</span><span class="n">send</span> <span class="ss">:define_method</span><span class="p">,</span> <span class="ss">:each_event</span> <span class="k">do</span> <span class="o">|&amp;</span><span class="n">block</span><span class="o">|</span>
    <span class="n">events</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">event</span><span class="o">|</span>
      <span class="n">block</span><span class="o">.</span><span class="n">call</span> <span class="n">event</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="no">Kernel</span><span class="o">.</span><span class="n">send</span> <span class="ss">:define_method</span><span class="p">,</span> <span class="ss">:each_setup</span> <span class="k">do</span> <span class="o">|&amp;</span><span class="n">block</span><span class="o">|</span>
    <span class="n">setups</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">setup</span><span class="o">|</span>
      <span class="n">block</span><span class="o">.</span><span class="n">call</span> <span class="n">setup</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="p">}</span><span class="o">.</span><span class="n">call</span>

<span class="nb">load</span> <span class="s1">&#39;events.rb&#39;</span>

<span class="c1"># env is created for each event to be a Clean Room</span>
<span class="n">each_event</span> <span class="k">do</span> <span class="o">|</span><span class="n">event</span><span class="o">|</span>
  <span class="n">env</span> <span class="o">=</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
  <span class="n">each_setup</span> <span class="k">do</span> <span class="o">|</span><span class="n">setup</span><span class="o">|</span>
    <span class="n">env</span><span class="o">.</span><span class="n">instance_eval</span> <span class="o">&amp;</span><span class="n">setup</span>
  <span class="k">end</span>
  <span class="nb">puts</span> <span class="s2">&quot;ALERT: </span><span class="si">#{</span><span class="n">event</span><span class="o">[</span><span class="ss">:description</span><span class="o">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">env</span><span class="o">.</span><span class="n">instance_eval</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">event</span><span class="o">[</span><span class="ss">:condition</span><span class="o">]</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p><strong><em>When is <code>yield</code> not enough to use?</em></strong></p>

<ul>
<li>You want to pass the block to another method (or even another block).</li>
<li>You want to convert the block to a <code>Proc</code>.</li>
</ul>

<h2>Proc Objects</h2>

<p>as blocks are not objects, Ruby provides the standard library class <code>Proc</code>. A <code>Proc</code> is a block that has been turned into an object. You can create a <code>Proc</code> by passing the block to <code>Proc.new</code>. Later, you can evaluate the block-turned-object with <code>Proc#call</code>.</p>

<p><strong>Deferred Evaluation</strong></p>
<div class="highlight"><pre><code class="ruby"><span class="n">inc</span> <span class="o">=</span> <span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
<span class="c1"># more code...</span>
<span class="n">inc</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># =&gt; 3</span>
</code></pre></div>
<p><strong>4 ways to create Procs explicitly</strong></p>
<div class="highlight"><pre><code class="ruby"><span class="no">Proc</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
<span class="nb">proc</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
<span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
<span class="o">-&gt;</span> <span class="n">x</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span> <span class="c1"># stabby lambda</span>
</code></pre></div>
<p><strong>Ways to create Procs implicitly</strong></p>

<p>use <code>&amp;</code> to convert block into a proc:</p>
<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">make_proc</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">p</span><span class="p">)</span>
  <span class="nb">p</span>
<span class="k">end</span>

<span class="n">make_proc</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</code></pre></div>
<p><strong>4 ways to call Procs</strong></p>
<div class="highlight"><pre><code class="ruby"><span class="nb">p</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="mi">41</span><span class="p">)</span>
<span class="nb">p</span><span class="o">[</span><span class="mi">41</span><span class="o">]</span>
<span class="nb">p</span> <span class="o">===</span> <span class="mi">41</span>
<span class="nb">p</span><span class="o">.</span><span class="p">(</span><span class="mi">41</span><span class="p">)</span>
</code></pre></div>
<p><strong>Use <code>&amp;</code> to convert a block to Proc</strong></p>
<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">my_method</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_proc</span><span class="p">)</span>
  <span class="n">the_proc</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="o">=</span> <span class="n">my_method</span> <span class="p">{</span><span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="s2">&quot;Hello, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">!&quot;</span> <span class="p">}</span>
<span class="nb">p</span><span class="o">.</span><span class="n">class</span>     <span class="c1"># =&gt; Proc</span>
<span class="nb">p</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;Bill&quot;</span><span class="p">)</span>  <span class="c1"># =&gt; &quot;Hello, Bill!&quot;</span>
</code></pre></div>
<p><strong>Use <code>&amp;</code> to convert a Proc to block</strong></p>
<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">my_method</span><span class="p">(</span><span class="n">greeting</span><span class="p">)</span>
    <span class="s2">&quot;</span><span class="si">#{</span><span class="n">greeting</span><span class="si">}</span><span class="s2">, </span><span class="si">#{</span><span class="k">yield</span><span class="si">}</span><span class="s2">!&quot;</span>
<span class="k">end</span>

<span class="n">my_proc</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span> <span class="s2">&quot;Bill&quot;</span> <span class="p">}</span>
<span class="n">my_method</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_proc</span><span class="p">)</span>
</code></pre></div>
<p><strong><em>What&#39;s a lambda?</em></strong></p>

<p>Procs created with <code>lambda</code> are called <em>lambdas</em>, while the others are simply called <em>procs</em>. (You can use the <code>Proc#lambda?</code> method to check whether the <code>Proc</code> is a lambda).</p>

<p><strong>Procs vs. Lambdas</strong></p>

<ul>
<li><p><code>return</code></p>

<p><code>lambda</code> returns just returns from the lambda, while a proc returns from the scope where the proc itself was defined.</p></li>
<li><p><strong>arity</strong></p>

<p>Call a <code>lambda</code> with the wrong arity, and it fails with an <code>ArgumentError</code>, while if there are too many arguments, a proc drops the excess arguments. If there are too few arguments, it assigns <code>nil</code> to the missing arguments.</p></li>
</ul>

<p>Generally speaking, <code>lambdas</code> are more intuitive than procs because they’re more similar to methods. They’re pretty strict about arity, and they simply exit when you call <code>return</code>.</p>

<p><strong>About the tolerance on arguments</strong></p>

<p>method == lambda &lt; proc == block</p>

<h3>Methods</h3>

<p>By calling <code>Kernel#method</code>, you get the method itself as a Method object, which you can later execute with <code>Method#call</code>. In Ruby 2.1, you also have <code>Kernel#singleton_method</code>, that converts the name of a Singleton Method to a Method object.</p>

<p><strong>Conversions between methods and procs</strong></p>

<ul>
<li>Use <code>Method#to_proc</code> to convert a method into proc.</li>
<li>Use <code>define_method</code> to convert a proc into method.</li>
</ul>

<p><strong>An important difference between methods and procs</strong></p>

<p>a <code>lambda</code> is evaluated in the scope it’s defined in (it’s a closure, remember?), while a <code>Method</code> is evaluated in the scope of its object.</p>

<h3>Unbound Methods</h3>

<p><code>UnboundMethods</code> are like <code>Methods</code> that have been detached from their original class or module.</p>

<p><strong>You can’t call an <code>UnboundMethod</code></strong>, but you can use it to generate a normal method that you can call.</p>

<p><strong>generate</strong></p>

<ul>
<li>use <code>Method#unbind</code></li>
</ul>
<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">foo</span><span class="p">;</span> <span class="k">end</span>
<span class="n">unbound</span> <span class="o">=</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span><span class="o">.</span><span class="n">unbind</span>
<span class="n">unbound</span><span class="o">.</span><span class="n">class</span>   <span class="c1"># =&gt; UnboundMethod</span>
</code></pre></div>
<ul>
<li>use <code>Module#instance_method</code></li>
</ul>
<div class="highlight"><pre><code class="ruby"><span class="k">module</span> <span class="nn">MyModule</span>
  <span class="k">def</span> <span class="nf">my_method</span>
  <span class="mi">42</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">unbound</span> <span class="o">=</span> <span class="no">MyModule</span><span class="o">.</span><span class="n">instance_method</span><span class="p">(</span><span class="ss">:my_method</span><span class="p">)</span>
<span class="n">unbound</span><span class="o">.</span><span class="n">class</span>   <span class="c1"># =&gt; UnboundMethod</span>
</code></pre></div>
<p><em>Note:</em> <code>instance_methods</code> is totally different, it&#39;s like <code>methods</code>, just return an array of symbols.</p>

<p><strong>usage</strong></p>

<ul>
<li>bind the UnboundMethod to an object with <code>UnboundMethod#bind</code>. UnboundMethods that come from a class can only be bound to objects of the same class (or a subclass), while UnboundMethods that come from a module have no such limitation from Ruby 2.0 onwards.</li>
<li>use an UnboundMethod to define a brand new method by passing it to <code>Module#define_method</code>.</li>
</ul>
<div class="highlight"><pre><code class="ruby"><span class="nb">String</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span>
  <span class="n">define_method</span> <span class="ss">:another_method</span><span class="p">,</span> <span class="n">unbound</span>
<span class="k">end</span>

<span class="s2">&quot;abc&quot;</span><span class="o">.</span><span class="n">another_method</span> <span class="c1"># =&gt; 42</span>
</code></pre></div>
<p><strong>example</strong></p>

<p>In ActiveSupport, the &#39;autoloading&#39; system includes a <code>Loadable</code> module, which redefines the standard <code>Kernel#load</code>. If a class includes <code>Loadable</code>, then <code>Loadable#load</code> gets lower then <code>Kernel#load</code> on its chain of ancestors.</p>

<p>And what if you want to stop using <code>Loadable#load</code> and go back to the plain vanilla <code>Kernel#load</code>?</p>

<p><code>ruby # gems/activesupport-4.0.2/lib/active_support/dependencies.rb
module Loadable
  def exclude_from(base)
    base.class_eval { define_method :load, Kernel.instance_method(:load) }
  end
end
</code></p>

<h1>Class Definitions</h1>

<p>In Java and C#, defining a class is like making a deal between you and the compiler.</p>

<p>In Ruby, class definitions are different. When you use the class keyword, you aren’t just dictating how objects will behave in the future. On the contrary, you’re actually running code.</p>

<h2>The Current Class</h2>

<p>Wherever you are in a Ruby program, you always have a current object: <code>self</code>. Likewise, you always have a current class (or module). As The Ruby interpreter always keeps a reference to the current class (or module), when you define a method, that method becomes an instance method of the current class.</p>

<p>Although you can get a reference to the current object through <code>self</code>, there’s no equivalent keyword to get a reference to the current class.</p>

<p><strong><em>How to keep track of the current class?</em></strong></p>

<ul>
<li>At the top level of your program, the current class is <code>Object</code>, the class of <code>main</code>. (That’s why, if you define a method at the top level, that method becomes an instance method of <code>Object</code>).</li>
</ul>
<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">foo</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span> <span class="k">end</span>
<span class="no">Object</span><span class="o">.</span><span class="n">instance_methods</span><span class="o">.</span><span class="n">grep</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span>      <span class="c1"># =&gt; []</span>
<span class="no">Object</span><span class="o">.</span><span class="n">private_instance_methods</span><span class="o">.</span><span class="n">grep</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span> <span class="c1"># =&gt; [:foo]</span>
</code></pre></div><div class="highlight"><pre><code class="ruby"><span class="o">[</span><span class="mi">6</span><span class="o">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span> <span class="k">end</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
<span class="o">[</span><span class="mi">7</span><span class="o">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">cd</span> <span class="no">Object</span>
<span class="o">[</span><span class="mi">8</span><span class="o">]</span> <span class="n">pry</span><span class="p">(</span><span class="no">Object</span><span class="p">):</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">show</span><span class="o">-</span><span class="nb">method</span> <span class="n">foo</span>

<span class="ss">From</span><span class="p">:</span> <span class="p">(</span><span class="n">pry</span><span class="p">)</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">4</span><span class="p">:</span>
<span class="ss">Owner</span><span class="p">:</span> <span class="no">Object</span>
<span class="ss">Visibility</span><span class="p">:</span> <span class="kp">private</span>
<span class="no">Number</span> <span class="n">of</span> <span class="ss">lines</span><span class="p">:</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span> <span class="k">end</span>
<span class="o">[</span><span class="mi">9</span><span class="o">]</span> <span class="n">pry</span><span class="p">(</span><span class="no">Object</span><span class="p">):</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">cd</span> <span class="o">.</span><span class="n">.</span>
</code></pre></div><div class="highlight"><pre><code class="ruby"><span class="c1"># foo.rb</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span> <span class="k">end</span>
<span class="nb">p</span> <span class="no">Object</span><span class="o">.</span><span class="n">private_instance_methods</span><span class="o">.</span><span class="n">grep</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span> <span class="c1"># =&gt; [:foo]</span>

<span class="c1"># console</span>
<span class="err">$</span> <span class="n">ruby</span> <span class="n">foo</span><span class="o">.</span><span class="n">rb</span> <span class="c1"># =&gt; [:foo]</span>
</code></pre></div>
<ul>
<li><p>In a method, the current class is the class of the current object.</p></li>
<li><p>When you open a class with the <code>class</code> keyword (or a module with the <code>module</code> keyword), that class becomes the current class.</p></li>
</ul>

<p><strong><em>How can you open the class if you don’t know its name?</em></strong></p>

<p>Use <code>Module#class_eval</code>.</p>

<p><strong><em>What&#39;s the advantage of <code>Module#class_eval</code> other than <code>class</code>?</em></strong></p>

<ul>
<li><code>Module#class_eval</code> is actually more flexible than class. You can use <code>class_eval</code> on any variable that references the class, while <code>class</code> requires a constant.</li>
<li><code>class</code> opens a new scope, losing sight of the current bindings, while <code>class_eval</code> has a <em>Flat Scope</em>.</li>
</ul>

<p><strong><em>When to use <code>class_eval</code>, and when <code>instance_eval</code>?</em></strong></p>

<p>Use <code>instance_eval</code> to open an object that is not a class, and <code>class_eval</code> to open a class definition and define methods with <code>def</code>.</p>

<p><strong><em>What&#39;s the difference between <code>class_eval</code> and <code>instance_eval</code>?</em></strong></p>

<p>Both changes <code>self</code>, and <code>class_eval</code> changes the current class to the caller&#39;s class, while <code>instance_eval</code> changes the current class to the caller&#39;s singleton class.</p>

<p><strong>An interesting knowledge about <code>Class.new</code></strong></p>
<div class="highlight"><pre><code class="ruby"><span class="n">c</span> <span class="o">=</span> <span class="no">Class</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">Array</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">my_method</span>
    <span class="s1">&#39;Hello!&#39;</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">MyClass</span> <span class="o">=</span> <span class="n">c</span>
<span class="n">c</span><span class="o">.</span><span class="n">name</span>  <span class="c1"># =&gt; &#39;MyClass&#39;</span>
</code></pre></div>
<p>When you assign an anonymous class to a constant, Ruby understands that you’re trying to give a name to the class, and it does something special: it turns around to the class and says, “Here’s your new name.” Now the constant references the Class, and the Class also references the constant. If it weren’t for this trick, a class wouldn’t be able to know its own name</p>

<h2>Class Instance Variables</h2>

<p>They’re just regular instance variables that happen to belong to an object of class <code>Class</code>. Because of that, a Class Instance Variable can be accessed only by the class itself— not by an instance or by a subclass.</p>

<p>No weird behaviors like Class Variables, which subclass and class share the same variable.</p>

<h2>Singleton Methods</h2>
<div class="highlight"><pre><code class="ruby"><span class="n">obj</span> <span class="o">=</span> <span class="no">Object</span><span class="o">.</span><span class="n">new</span>
<span class="k">def</span> <span class="nc">obj</span><span class="o">.</span><span class="nf">foo</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span> <span class="k">end</span>
</code></pre></div>
<p>A method which is specific to a single object, is called Singleton Methods.</p>

<p>You can also use <code>Object#define_singleton_method</code>: (Remeber <code>Module#define_method</code>?)</p>
<div class="highlight"><pre><code class="ruby"><span class="n">obj</span><span class="o">.</span><span class="n">define_singleton_method</span> <span class="ss">:bar</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s1">&#39;bar&#39;</span> <span class="p">}</span>
</code></pre></div>
<p><strong><em>What is the Class Macro?</em></strong></p>

<p>A method such as <code>attr_accessor</code> is called a Class Macro. Class Macros look like keywords, but they’re just regular class methods that are meant to be used in a class definition.</p>

<h2>Singleton Class</h2>

<p>A singleton class is where an object’s Singleton Methods live</p>

<p><strong><em>How to get?</em></strong></p>

<ul>
<li>Use the <code>&lt;&lt;</code> syntax.</li>
</ul>
<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nc">obj</span><span class="o">.</span><span class="nf">my_singleton_method</span><span class="p">;</span> <span class="k">end</span>
<span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">;</span> <span class="nb">instance_methods</span><span class="o">.</span><span class="n">grep</span><span class="p">(</span><span class="sr">/my_/</span><span class="p">);</span> <span class="k">end</span>
</code></pre></div><div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">Foo</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">&#39;Foo.bar&#39;</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="o">.</span><span class="n">new</span>
<span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span>
  <span class="k">def</span> <span class="nf">bar</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">&#39;foo.bar&#39;</span><span class="p">;</span> <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<ul>
<li>Use <code>Object#singleton_class</code></li>
</ul>
<div class="highlight"><pre><code class="ruby"><span class="n">obj</span><span class="o">.</span><span class="n">singleton_class</span><span class="o">.</span><span class="n">instance_methods</span><span class="o">.</span><span class="n">grep</span><span class="p">(</span><span class="sr">/my_/</span><span class="p">)</span>
</code></pre></div>
<p><strong>Singleton classes and inheritance</strong></p>

<p><img src="https://dl.dropboxusercontent.com/s/leu6dh1ro55u149/singleton_classes_and_inheritance.png?dl=1&amp;token_hash=AAFdcu5UXq5RMpm7nkaQf_B5Und9FjuPF85b35aIWXjC1g&amp;expiry=1400340965" alt="singleton_classes_and_inheritance"></p>

<p><strong>7 rules of the Ruby object model</strong></p>

<blockquote>
<p>The Ruby object model is a beautiful place,” Bill notes, with a dreamy expres- sion on his face. “There are classes, singleton classes, and modules. There are instance methods, class methods, and singleton methods.</p>
</blockquote>

<ol>
<li>There is only one kind of object—be it a regular object or a module.</li>
<li>There is only one kind of module—be it a regular module, a class, or a singleton class.</li>
<li>There is only one kind of method, and it lives in a module—most often in a class.</li>
<li>Every object, classes included, has its own “real class,” be it a regular class or a singleton class.</li>
<li>Every class, with the exception of <code>BasicObject</code>, has exactly one ancestor— either a superclass, or a module. This means you have a single chain of ancestors from any class up to <code>BasicObject</code>.</li>
<li>The superclass of the singleton class of an object is the object’s class. The superclass of the singleton class of a class is the singleton class of the class’s superclass.</li>
<li>When you call a method, Ruby goes “right” in the receiver’s real class and then “up” the ancestors chain. That’s all there is to know about the way Ruby finds methods.</li>
</ol>

<p><strong><em>Can object&#39;s Singleton Class touch the its Instance Variable?</em></strong></p>
<div class="highlight"><pre><code class="ruby"><span class="c1"># exampel 1</span>

<span class="k">class</span> <span class="nc">MyClass</span>
  <span class="k">def</span> <span class="nf">name</span><span class="p">;</span> <span class="vi">@name</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">name</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="vi">@name</span><span class="o">=</span><span class="n">n</span><span class="p">;</span> <span class="k">end</span>
<span class="k">end</span>

<span class="n">obj</span> <span class="o">=</span> <span class="no">MyClass</span><span class="o">.</span><span class="n">new</span>
<span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span>
<span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="c1"># =&gt; &#39;foo&#39;</span>

<span class="n">obj</span><span class="o">.</span><span class="n">instance_eval</span> <span class="p">{</span> <span class="k">def</span> <span class="nf">to_s</span><span class="p">;</span> <span class="s2">&quot;My name is </span><span class="si">#@name</span><span class="s2">&quot;</span><span class="p">;</span> <span class="k">end</span> <span class="p">}</span>
<span class="n">obj</span><span class="o">.</span><span class="n">to_s</span> <span class="c1"># =&gt; &quot;My name is foo&quot;</span>

<span class="c1"># example2</span>

<span class="k">class</span> <span class="nc">MyClass</span>
  <span class="vi">@age</span> <span class="o">=</span> <span class="mi">42</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">age</span><span class="p">;</span> <span class="vi">@age</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">MyClass</span><span class="o">.</span><span class="n">age</span> <span class="c1"># =&gt; 42</span>
</code></pre></div>
<p>Yes, it can. So I can assume the obj&#39;s Instance Variable lives in its Singleton Class.</p>

<p><strong><em>Can a module&#39;s singleton methods be included?</em></strong></p>

<p>No!</p>

<p>When a class includes a module, it gets the module’s instance methods—not the class methods. Class methods stay out of reach, in the module’s singleton class.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">module</span> <span class="nn">M</span>
  <span class="k">def</span> <span class="nf">foo</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">bar</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span> <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">C</span>
  <span class="kp">include</span> <span class="n">M</span>
<span class="k">end</span>

<span class="n">C</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">foo</span> <span class="c1"># =&gt; &#39;foo&#39;</span>
<span class="n">C</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">bar</span> <span class="c1"># =&gt; NoMethodError</span>

<span class="k">class</span> <span class="nc">C</span>
  <span class="kp">extend</span> <span class="n">M</span>
<span class="k">end</span>

<span class="n">C</span><span class="o">.</span><span class="n">bar</span> <span class="c1"># =&gt; NoMethodError</span>
<span class="n">C</span><span class="o">.</span><span class="n">foo</span> <span class="c1"># =&gt; &#39;foo&#39;</span>
</code></pre></div>
<p><strong><em>What&#39;s the difference between <code>Module#include</code> and <code>Object#extend</code>?</em></strong></p>

<ul>
<li><code>Module#include</code> includes a module in the receiver&#39;s class.</li>
<li><code>Object#extend</code> includes a module in the receiver&#39;s singleton class.</li>
</ul>

<h2>Method Wrapper</h2>

<ul>
<li>Around Alias</li>
<li>Refinement Wrapper</li>
<li>Prepended Wrapper(<code>Module#prepend</code>)</li>
</ul>

<p>Selection: Prepended Wrapper &gt; Refinement Wrapper &gt; Around Alias</p>

<h3>Around Alias</h3>

<p><strong><code>alias</code> vs. <code>alias_method</code></strong></p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">MyClass</span>
  <span class="k">alias</span> <span class="ss">:new_foo</span> <span class="ss">:foo</span>
  <span class="n">alias_method</span> <span class="ss">:another_new_foo</span><span class="p">,</span> <span class="ss">:foo</span>
<span class="k">end</span>
</code></pre></div>
<ul>
<li><code>alias</code> is a keyword.</li>
<li><code>alias_method</code> is an instance method of Module. <code>Module#alias_method</code></li>
</ul>

<p><strong><em>Can you alias a method before it defined?</em></strong></p>

<p>No!</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">MyClass</span>
  <span class="n">alias_method</span> <span class="ss">:new_foo</span><span class="p">,</span> <span class="ss">:foo</span>
  <span class="k">def</span> <span class="nf">foo</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span> <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># =&gt; NameError: undefined method `foo&#39; for class `MyClass&#39;</span>
</code></pre></div>
<p><strong><em>Can aliases break the class&#39;s encapsulation?</em></strong></p>

<p>Yes!</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">MyClass</span>
  <span class="n">alias_method</span> <span class="ss">:new_foo</span><span class="p">,</span> <span class="ss">:foo</span>

  <span class="kp">private</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">;</span> <span class="nb">puts</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">end</span>

  <span class="no">MyClass</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">foo</span>     <span class="c1"># =&gt; NoMethodError: private method `foo&#39; called</span>
  <span class="no">MyClass</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">new_foo</span> <span class="c1"># =&gt; &#39;foo&#39;</span>
</code></pre></div>
<p><strong><em>How to write an Around Alias?</em></strong></p>

<ol>
<li>You alias a method.</li>
<li>You redefine it.</li>
<li>You call the old method from the new method.</li>
</ol>

<p><strong>Downsides</strong></p>

<ul>
<li>They pollute your classes with one additional method name. You can fix this small problem somehow by making the old version of the method <code>private</code> after you alias it.</li>
<li>The loading issue. You should never load an Around Alias twice, unless you want to end up with an exception when you call the method.</li>
</ul>

<p>The main issue with Around Aliases, however, is that they are a form of Monkeypatching. Like all Monkeypatches, they can break existing code that wasn’t expecting the method to change.</p>

<h3>Refinement Wrapper</h3>

<p><strong>Advantage over Around Alias</strong></p>

<p>If you call <code>super</code> from a refined method, you will call the original, unrefined method.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">module</span> <span class="nn">StringRefinement</span>
  <span class="n">refine</span> <span class="nb">String</span> <span class="k">do</span>
    <span class="k">def</span> <span class="nf">length</span>
      <span class="k">super</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="o">?</span> <span class="s1">&#39;long&#39;</span> <span class="p">:</span> <span class="s1">&#39;short&#39;</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">using</span> <span class="no">StringRefinement</span>
<span class="s2">&quot;War and Peace&quot;</span><span class="o">.</span><span class="n">length</span> <span class="c1"># =&gt; &quot;long&quot;</span>
</code></pre></div>
<h3>Prepended Wrapper</h3>

<p>A method in a prepended module can override a method in the includer, and call the non- overridden version with <code>super</code>.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">module</span> <span class="nn">ExplicitString</span>
  <span class="k">def</span> <span class="nf">length</span>
    <span class="k">super</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="o">?</span> <span class="s1">&#39;long&#39;</span> <span class="p">:</span> <span class="s1">&#39;short&#39;</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">String</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span>
  <span class="n">prepend</span> <span class="no">ExplicitString</span>
<span class="k">end</span>

<span class="s2">&quot;War and Peace&quot;</span><span class="o">.</span><span class="n">length</span> <span class="c1"># =&gt; &quot;long&quot;</span>
</code></pre></div>
<p><strong><em>Advantage over Refinement Wrapper and Around Alias?</em></strong></p>

<p>It’s generally considered cleaner and more explicit than both a Refinement Wrapper and an Around Alias.</p>

<h3>An interesting quiz solving by Around Alias</h3>

<p>Make it work:</p>
<div class="highlight"><pre><code class="ruby"><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># =&gt; 3</span>
</code></pre></div>
<p>You can solve this quiz with an Open Class. Just reopen <code>Fixnum</code>, and redefine <code>+</code> so that <code>(x+y)</code> becomes <code>(x+y+1)</code>. This is not as easy as it seems, however. The new version of + relies on the old version of +, so you need to wrap your old version with the new version.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">Fixnum</span>
  <span class="n">alias_method</span> <span class="ss">:old_plus</span><span class="p">,</span> <span class="ss">:+</span>

  <span class="k">def</span> <span class="nf">+</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">old_plus</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">old_plus</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<h1>Eval and Binding</h1>

<p><code>Kernel#eval</code> Evaluates the Ruby expression(s) in string. If binding is given, which must be a <code>Binding</code> object, the evaluation is performed in its context.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">get_binding</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
  <span class="nb">binding</span>
<span class="k">end</span>

<span class="n">str</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span>
<span class="nb">eval</span> <span class="s2">&quot;str + &#39; Fred&#39;&quot;</span>                     <span class="c1"># =&gt; &quot;hello Fred&quot;</span>
<span class="nb">eval</span> <span class="s2">&quot;str + &#39; Fred&#39;&quot;</span><span class="p">,</span> <span class="n">get_binding</span><span class="p">(</span><span class="s1">&#39;bye&#39;</span><span class="p">)</span> <span class="c1"># =&gt; &quot;bye Fred&quot;</span>
</code></pre></div>
<p><code>Kernel#binding</code> Returns a <code>Binding</code> object, describing the variable and method bindings at the point of call. This object can be used when calling eval to execute the evaluated command in this environment.</p>

<p>Ruby also provides a predefined constant named <code>TOPLEVEL_BINDING</code>, which is just a Binding of the top-level scope.</p>

<p>You can also use <code>Proc#binding</code> to return a <code>Binding</code> object.</p>
<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">get_proc</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
  <span class="o">-&gt;</span> <span class="p">{}</span>
<span class="k">end</span>

<span class="nb">eval</span> <span class="s2">&quot;str + &#39;Fred&#39;&quot;</span><span class="p">,</span> <span class="n">get_proc</span><span class="p">(</span><span class="s1">&#39;bye&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">binding</span> <span class="c1"># =&gt; &quot;bye Fred&quot;</span>
</code></pre></div><div class="highlight"><pre><code class="ruby"><span class="n">l</span> <span class="o">=</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="nb">name</span> <span class="o">=</span> <span class="s1">&#39;wendi&#39;</span> <span class="p">}</span>
<span class="nb">eval</span> <span class="s2">&quot;puts name&quot;</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">binding</span>
<span class="c1"># =&gt; NameError: undefined local variable or method `name&#39; for main:Object`</span>

<span class="k">def</span> <span class="nf">bar</span>
  <span class="nb">name</span> <span class="o">=</span> <span class="s1">&#39;wendi&#39;</span>
  <span class="o">-&gt;</span> <span class="p">{}</span>
<span class="k">end</span>
<span class="nb">eval</span> <span class="s2">&quot;puts name&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="o">.</span><span class="n">binding</span>
<span class="c1"># =&gt; wendi</span>
</code></pre></div>
<p><strong><em>What&#39;s to concern when using <code>eval</code>?</em></strong></p>

<ul>
<li><p>As it only accepts strings of codes but not blocks, it&#39;s not editor friendly(syntax highlighting) and hard to trace syntax errors.</p></li>
<li><p>Code Injection.</p></li>
</ul>

<p><strong><em>What&#39;s the soluction Ruby provided for <code>eval</code> insecurity?</em></strong></p>

<ul>
<li><p>Tainted Objects, <code>Object#tainted?</code>, <code>Object#untaint</code></p></li>
<li><p>Safe Levels, <code>$SAFE</code></p>

<ul>
<li>0, “hippie commune&quot;, where you can hug trees and format hard disks.</li>
<li>Any safe level greater than 0 also causes Ruby to flat-out refuse to evaluate tainted string.</li>
<li>2, disallows most file-related operations.</li>
<li>3, “military dictatorship,” where every object you create is tainted by default.</li>
</ul></li>
</ul>

<p><strong><em>How to write a Sandbox for <code>eval</code>?</em></strong></p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="nc">ERB</span>
  <span class="k">def</span> <span class="nf">result</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">new_toplevel</span><span class="p">)</span>
    <span class="k">if</span> <span class="vi">@safe_level</span>
      <span class="nb">proc</span> <span class="p">{</span>
        <span class="vg">$SAFE</span> <span class="o">=</span> <span class="vi">@safe_level</span>
        <span class="nb">eval</span><span class="p">(</span><span class="vi">@src</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="vi">@filename</span> <span class="o">||</span> <span class="s1">&#39;(erb)&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">}</span><span class="o">.</span><span class="n">call</span>
    <span class="k">else</span>
      <span class="nb">eval</span><span class="p">(</span><span class="vi">@src</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="vi">@filename</span> <span class="o">||</span> <span class="s1">&#39;(erb)&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[姜昕 - 长发飞扬的日子]]></title>
    <link href="http://ifyouseewendy.github.io/blog/2014/06/03/jiang-xin-chang-fa-fei-yang-de-ri-zi/"/>
    <updated>2014-06-03T00:34:18+08:00</updated>
    <id>http://ifyouseewendy.github.io/blog/2014/06/03/jiang-xin-chang-fa-fei-yang-de-ri-zi</id>
    <content type="html"><![CDATA[<p>阴雨连绵会让我觉得他是，好天气反而会让我坐立不安。</p>

<p>我久久地注视着那个方向，终于明白其实我们都只是在寻找我们各自的过去，而那种寻找是徒劳的。</p>

<p>爱是一种在一瞬间就忽然降临的东西，是让你猝不及防却又挥之不去的东西。如果你犹豫再三，如果你反复掂量，那它就掺进了杂质，变成了表面上与爱情类似却又远不能急的另一种情感。</p>

<p>虽然我和夏旸后来分开了，彼此也都曾给对方造成过伤害，可是，我从不怀疑他曾经对我说过的誓言——因为后来我终于知道了：誓言不见得是会实现的——年轻的誓言其实是你一生中曾经绽放的最绚烂的花朵。等到有一天，你再也听不到它而且自己也不会再说的时候，其实，那正是成长的悲哀。</p>

<p>所以，对摇滚乐这一名词，我是这样理解的：它就像当初崔健诠释他自己的名字的那句话——就是一种“摧毁”和一种“建立”。它不应该局限于任何一种和声走势，也不应该局限于任何一种表演形式或表面现象，它是“点燃”，用从一些心灵发出的声音将另外一些心灵“点燃”。</p>

<p>崔健说得特别号：“我没有老，因为我还有质疑这个世界的能力！”</p>

<p>他找到了新的方向——那一切的改变，是因为 [Peter Murphy](http://en.wikipedia.org/wiki/Peter<em>Murphy</em>(musician)) 在 Bauhaus 时期的两张唱片——<a href="http://www.xiami.com/album/50278?spm=0.0.0.0.vuZDIm">In The Flat Field</a>、<a href="http://www.xiami.com/album/50279?spm=0.0.0.0.vuZDIm">Mask</a>，尤其是他离开乐队之后发行的那张个人专辑 <a href="http://www.xiami.com/album/55495?spm=0.0.0.0.7DIi01">Deep</a>。</p>

<p>很多年后回头再看，我才真正意识到当年那么年轻的他能做到这一点有多么难得，他并没有因为一时的成功就忘乎所以、不可一世。而能够在名利双收的时候选择离开、在功成名就以后仍然一直将自己的注意力放在音乐上，这样的人一直是我敬佩的。</p>

<p>生活并不像我们最初想象的那样，可是，好天气还会有，所以，最傻的事情就是在一个阴霾的天气中绝望。</p>

<p>-- “这些天我一直在想，当初选择做音乐到底是为了什么？难道就是为了出唱片，被好多人捧着、盯着？可那样幸福吗？”<br>
-- “可你舍得放弃吗？那样你就会觉得幸福了吗？”
-- “要是有一天我做的音乐一钱不值，再没有人说它们好，你会怎么想？会失望吗？”<br>
-- “不会的！我相信你！”
-- “所以说，这是条‘贼船’，上去就很难下来了！连你都这么想——不会的！的确，我是舍不得放弃，我已经‘中毒‘太深了……可是我怎么觉得，我的幸福也都被它毁了……我不知道我在对谁负责、谁又能对我负责！”</p>

<p>今年年初，一个偶然的早晨，我们坐在“永和豆浆”一起吃早点，又谈起那段往事，我说：“还记得吗？你那个无比美好的理想。可是为什么在我告诉你我已经爱上另一个男人的时候，你又掐着我的脖子把我堵在墙角里了？还说女人真狠！得承认你还是自私的吧？”</p>

<p>那天晚上，我拆开那个信封，里边是一张白色的硬纸壳儿，上边是一个“梦”字，不过那不仅仅是一个字，那其实是一幅画。上边“林”字的“横撇竖捺”画的是牛仔裤的侧面、牙膏牙刷、烟、打火机和笔；下面“夕”字的两撇是我和他的背影；一横是一张一百块钱的正面，四个“老人”换成了他乐队的四个人，发型怪异戴着墨镜，其中三个还分别拿着吉他、贝斯和鼓槌，那一点则是一个“？”。</p>

<p>信封里没有照片，也没有画，那同样是两张牛皮纸，只不过比信封的质地稍薄，背面是放大的石膏头像，右上角印着四行小字：</p>

<ul>
<li>多而乱的皱纹是岁月层层叠叠的刻度<br></li>
<li>大小深浅的斑点是过去的记忆<br></li>
<li>这就是平稳平淡的艺术生活<br></li>
<li>创造出丰富的艺术生命<br></li>
</ul>

<p>最后面是四个大字：  </p>

<ul>
<li>留驻记忆</li>
</ul>

<p>如果有一天，一个人能够面容坦然地说：I&#39;m alone, but not lonely。我以为那样的他（她）才是真的成熟了——所以，我最欣赏的气质，是坦然。</p>

<p>当我们的路通向另一个黑暗森林，追寻来时的脚步是多么困难！当路被设定好了，回归似乎不可能。生命就是我们的契约，但是除了最高法庭之外，无人能撤销它；在这样的夜里，死亡看来非常遥远，可是我们知道这是自欺欺人。我们没有时间看见最暗淡的星自我们眼角消失。当它们熄灭，我们会等待更明亮的傍晚。或者，瞻仰它们的光彩，让我们多么焦虑。我从不知有任何快乐可以不带来焦虑。但我们很愿意付出这样的代价……
-- Emily Dickenson</p>

<p>那天晚上，他们玩过一个游戏，用一本不知被谁一摞的成语字典彼此算命。每个轮到的人随意选择一个页数，并且选择那一页从上到下的某个成语。大家试过，都觉得准的不行！他们是按照年龄顺序进行的，最后轮到峻峻，他是乐队里年龄最小的一个。他那一条是——风流云散。</p>

<p>仅仅两年多的时间，让一个人从“长发飞扬”到“怪毛林立”，再到“一毛不拔”，这选择和放弃到底意味着什么呢？</p>

<p>门厅中最惨烈的就是那个杯子，它粉身碎骨在一滩水渍中，就像那是它的血。</p>

<p>我们都失败过，所以应该更加懂得怎么去保护我们的镜子。他还说，我们不要像从前那样，在一份感情里交付盲目的热情，我们唯一需要交付的，是自己心里的坦然。这个世界的诱惑很多，可我们必须明白——每一次心旌摇动，即使对方不知道，那面镜子也照得见，而且它会出现裂痕。所以，如果我们只想一位地任随心意，就不要在一起；如果打算在一起，就不要欺骗那面镜子。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[韩寒 - 我所理解的生活]]></title>
    <link href="http://ifyouseewendy.github.io/blog/2014/05/18/han-han-wo-suo-li-jie-de-sheng-huo/"/>
    <updated>2014-05-18T18:00:46+08:00</updated>
    <id>http://ifyouseewendy.github.io/blog/2014/05/18/han-han-wo-suo-li-jie-de-sheng-huo</id>
    <content type="html"><![CDATA[<p>这世道觉得文绉绉的诬陷没问题，这世道让那些不说粗话但最缺德的人能做道德评判家，这世道让那些话不脏但心眼脏、手段脏的人当道，这世道能任意颠倒黑白、混淆是非，这世道觉得公众人物或者随便谁说一个“操”字就不应该，那就操翻这世道。</p>

<p>很多人恨特权，因为特权没有在自己手中。</p>

<p>还有某些人开会制定了应对措施，这些措施中甚至包括联合一些专职黑我的人再次对我进行诽谤和攻击。当然，最后这些没有实施，因为他们发现所谓黑，都是无需组织的，我如果说饭能吃屎不能吃，他们都能捧着马桶干杯。</p>

<p>缘分不是走在街上非要撞见，缘分就是睡前醒后彼此想念。</p>

<p>没人能让所有人满意，所以让自己和你中意的人满意就可以了。你所判定的一切，也许就是你自己内心的投影。</p>

<p>我也将尽我所能，为在乎我的人创造各种东西，绝不向厌恶我的人解释这是个什么东西。</p>

<p>我是一个虚荣的人，有时候甚至还虚伪。由于我得到的越来越多，所以也可以假装越来越不虚荣，因为有了一些真荣。但我的内心还是虚荣的。不出席所有颁奖典礼、不去各种上流场合其实是另外一种虚荣，并不是淡泊。</p>

<p>开了几天的微博，我陷入了一种意淫的豪迈。</p>

<p>我越来越觉得很多东西的结果，其实并不是不同人的改变，而只是同类人的聚集。在我的微博马甲里，你觉得这个政府糟透了，时日不多。在别人的微博马甲里，你觉得生活挺安逸的，一切都好。所以，你所关注的一切，就是你所看到的世界。</p>

<p>每个人的道路都不同，我走在我的野路上，她走在她的大路上，都值得祝福。只要不走歪路邪路，每条道路都有成功的方式。黄思路也是，</p>

<p>你知道你能做到，别人觉得你也许可以做到，那么，少废话，做到再说，其他的怨气都是虚妄。</p>

<p>这枚碎片不是新型的，也不是心形的，它的不规则是规则的。</p>

<p>至少在文字中你很擅长论理，对你来说，论理这个事，最重要的一点是什么？我觉得论理最重要的一点就是不用典。</p>

<p>互联网多年，出现了很多聪明人，但完全没能稀释这个世界上笨蛋的浓度。</p>

<p>写作三种：说服你，拉拢他，剖析我。最早的我一直在第一种，后来发现容易背叛自己。于是我到了第二种，又发现容易迎合大众。我一直在去往第三种，路上有反复，有踌躇，有代价，有痛苦，但那才是一个真正的写作者要去的地方。否则你只是一个饭局作家，一个去了香港买了本地摊杂志就假装知道中国政治内幕。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Rails 4 Way - Environments and Configurations]]></title>
    <link href="http://ifyouseewendy.github.io/blog/2014/05/18/the-rails-4-way-environments-and-configurations/"/>
    <updated>2014-05-18T16:10:42+08:00</updated>
    <id>http://ifyouseewendy.github.io/blog/2014/05/18/the-rails-4-way-environments-and-configurations</id>
    <content type="html"><![CDATA[<h2>Bundler <a href="http://bundler.io">ref</a></h2>

<p>Bundler does gem dependency resolution based on Gemfile.</p>

<h4><code>~&gt;</code> operator</h4>

<p>The specifier <strong>~&gt;</strong> has a special meaning, best shown by example. <code>~&gt; 2.0.3</code> is identical to <code>&gt;= 2.0.3</code> and <code>&lt; 2.1</code>. <code>~&gt; 2.1</code> is identical to <code>&gt;= 2.1</code> and <code>&lt; 3.0</code>. <code>~&gt; 2.2.beta</code> will match prerelease versions like <code>2.2.beta.12</code>.</p>

<p><code>ruby hello linenos:false
gem &#39;thin&#39;,  &#39;~&gt;1.1&#39;
</code></p>

<h4><code>require</code></h4>

<p>Occasionally, the name of the gem that should be used in a require statement is
different than the name of that gem in the repository. In those cases, the <strong>:require</strong>
option solves this simply and declaratively right in the Gemfile.</p>
<div class="highlight"><pre><code class="ruby"><span class="n">gem</span> <span class="s1">&#39;sqlite3-ruby&#39;</span><span class="p">,</span> <span class="ss">:require</span> <span class="o">=&gt;</span> <span class="s1">&#39;sqlite3&#39;</span>
</code></pre></div>
<h4>group</h4>
<div class="highlight"><pre><code class="ruby"><span class="n">gem</span> <span class="s1">&#39;wirble&#39;</span><span class="p">,</span> <span class="ss">:group</span> <span class="o">=&gt;</span> <span class="ss">:development</span>
<span class="n">gem</span> <span class="s1">&#39;ruby-debug&#39;</span><span class="p">,</span> <span class="ss">:group</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="ss">:development</span><span class="p">,</span> <span class="ss">:test</span><span class="o">]</span>

<span class="n">group</span> <span class="ss">:test</span> <span class="k">do</span>
  <span class="n">gem</span> <span class="s1">&#39;rspec&#39;</span>
<span class="k">end</span>
</code></pre></div>
<h4>bundle install/update</h4>
<div class="highlight"><pre><code class="ruby"><span class="o">-&gt;</span> <span class="n">calculate</span> <span class="n">a</span> <span class="n">dependency</span> <span class="n">tree</span> <span class="o">-&gt;</span> <span class="n">generate</span> <span class="no">Gemfile</span><span class="o">.</span><span class="n">lock</span>
</code></pre></div>
<h4>bundle package</h4>

<blockquote>
<p>it will package up all your gems in <strong>vendor/cache</strong> directory. Running <strong>bundle install</strong> will use the gems in package and skip connecting to rubygems.org. use this to avoid external dependencies at deploy time, or if you depend on private gems that you are not available in any public repository.</p>
</blockquote>

<h4>bundle exec</h4>

<p>Non-Rails scripts must be executed with this to get a properly initialized RubyGems environment.</p>

<h4>bundle install --path vender/bundle --binstubs</h4>

<p>The default location for gems installed by bundler is directory named <strong>.bundle</strong> in your user directory.</p>

<p>This command will generate <strong>.bundle/config</strong> file:</p>

<h2>```ruby .bundle/config</h2>

<p>BUNDLE<em>BIN: bundler</em>stubs
BUNDLE<em>PATH: vendor/bundle
BUNDLE</em>DISABLE<em>SHARED</em>GEMS: &quot;1&quot;
```</p>

<p>gems in <strong>verdor/cache</strong>, and installed in <strong>vendor/bundle</strong>.</p>

<h4>bundle install vendor --disable-shared-gems</h4>

<blockquote>
<p>This command tells Bundler to install gems even if they are already installed in the system. Normally Bunlder avoids that symlinks to already downloaded gems that exists in your system. This option is useful when you are trying to package up an application that all dependencies unpacked.</p>
</blockquote>

<h2>Startup and Application Settings</h2>

<p><code>boot.rb</code></p>

<ul>
<li>sets up Bundler and load paths</li>
</ul>

<p><code>application.rb</code></p>

<ul>
<li>require &#39;boot&#39;</li>
<li>load rails gems, gems for the specified Rail.env, and configures the application ( <strong>define Application class</strong> ).</li>
</ul>

<p><code>environment.rb</code></p>

<ul>
<li>require &#39;application&#39;</li>
<li>runs all initializers ( <code>Application.initialize!</code> )</li>
</ul>

<p><code>environments/development.rb | test.rb | production.rb</code></p>

<ul>
<li>makes environmental configuraions.</li>
<li>application.rb makes unenvironmental configurations, like time-zone, autoload_paths, encoding.</li>
</ul>

<h2>Configurations</h2>

<h4>Wrap Parameters</h4>

<p>Introduced in Rails 3.1, the <code>wrap_parameters.rb</code> initializer configures your application to work with JavaScript MVC frameworks.</p>

<p>When submitting JSON parameters to a controller, Rails will wrap the parameters into a nested hash, with the controller’s name being set as the key. To illustrate, consider the following JSON:</p>
<div class="highlight"><pre><code class="ruby"><span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;TheRails4Way&quot;</span><span class="p">}</span>
</code></pre></div>
<p>If a client submitted the above JSON to a controller named ArticlesController, Rails would nest the params hash under the key “article”. This ensures the setting of model attributes from request parameters is consistent with the convention used when submitting from Rails form helpers.</p>
<div class="highlight"><pre><code class="ruby"><span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;TheRails4Way&quot;</span><span class="p">,</span> <span class="s2">&quot;article&quot;</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;TheRails4Way&quot;</span><span class="p">}}</span>
</code></pre></div>
<h4>Schema Dumper</h4>
<div class="highlight"><pre><code class="ruby"><span class="n">config</span><span class="o">.</span><span class="n">active_record</span><span class="o">.</span><span class="n">schema_format</span> <span class="o">=</span> <span class="ss">:sql</span>
</code></pre></div>
<p>Every time you run tests, Rails dumps the schema of your development database and copies it to the test database using an auto generated <code>schema.rb</code> script. It looks very similar to an Active Record migration script; in fact, it uses the same API.</p>

<h4>Automatic Class Reloading</h4>
<div class="highlight"><pre><code class="ruby"><span class="n">config</span><span class="o">.</span><span class="n">cache_classes</span> <span class="o">=</span> <span class="kp">false</span>
</code></pre></div>
<p>Without getting into too much nitty-gritty detail, when the config.cache_classes setting is true,Rails willuse Ruby’s <code>require</code> statement to do its class loading, and when it is false, it will use <code>load</code> instead.</p>

<p>When you require a Ruby file, the interpreter executes and caches it. If the file is required again (as in subsequent requests), the interpreter ignores the require statement and moves on. When you load a Ruby file, the interpreter executes the file again, no matter how many times it has been loaded before.</p>

<h4>Auto-Loading Code</h4>

<p>By following the naming convention, Rails will search <code>$LOAD_PATH</code> to find the undefined constant. So when using Rails console, <strong>you never have to explicitly <code>require</code> anything!</strong></p>

<p>Rails takes advantage of the fact that Ruby provides a callback mechanism for missing constants. When Rails encounters an undefined constant in the code, it uses a class loader routine based on file-naming conventions to find and require the needed Ruby script.</p>

<h4>Eager Load</h4>
<div class="highlight"><pre><code class="ruby"><span class="n">config</span><span class="o">.</span><span class="n">eager_load</span> <span class="o">=</span> <span class="kp">false</span>
</code></pre></div>
<p>In your production environment, you will want this set to true, as it copies most of your application in memory. This provides a performance increase to web servers that copy on write, such as Unicorn.</p>

<h4>Explain for Slow Queries</h4>
<div class="highlight"><pre><code class="ruby"><span class="n">config</span><span class="o">.</span><span class="n">active_record</span><span class="o">.</span><span class="n">auto_explain_threshold_in_seconds</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span>
</code></pre></div>
<p>Introduced in Rails 3.2, Active Record now monitors the threshold of SQL queries being made. If any query takes longer than the specified threshold, the query plan is logged with a warning.</p>

<h4>Assets</h4>
<div class="highlight"><pre><code class="ruby"><span class="n">config</span><span class="o">.</span><span class="n">assets</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kp">true</span>
</code></pre></div>
<p>Setting config.assets.debug to false, would result in Sprockets concatenating and running preprocessors on all assets.</p>
<div class="highlight"><pre><code class="ruby"><span class="n">config</span><span class="o">.</span><span class="n">assets</span><span class="o">.</span><span class="n">compile</span> <span class="o">=</span> <span class="kp">true</span>
</code></pre></div>
<p>If an asset is requested that does not exist in the public/assets folder, Rails will throw an exception. To enable live asset compilation fallback on production, set config.assets.compile to true.</p>
<div class="highlight"><pre><code class="ruby"><span class="n">config</span><span class="o">.</span><span class="n">assets</span><span class="o">.</span><span class="n">enable</span> <span class="o">=</span> <span class="kp">false</span>
</code></pre></div>
<p>Like most features in Rails, the usage of the Asset Pipeline is completely optional. To include assets in your project as it was done in Rails 3.0, set config.assets.enabled to false.</p>

<h4>Tagged Logging <a href="http://arun.im/2011/x-request-id-tracking-taggedlogging-rails">ref</a></h4>
<div class="highlight"><pre><code class="ruby"><span class="n">config</span><span class="o">.</span><span class="n">log_tags</span> <span class="o">=</span> <span class="o">[</span> <span class="ss">:subdomain</span><span class="p">,</span> <span class="ss">:uuid</span> <span class="o">]</span>
</code></pre></div>
<p>Rails 3.2 introduced the ability to tag your log messages. <code>:subdomain</code> example by <em>www</em>, <code>:uuid</code> is a string to identify request, try <code>request.uuid</code>.</p>
]]></content>
  </entry>
  
</feed>
