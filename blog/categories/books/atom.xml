<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Books | Wendi's Blog]]></title>
  <link href="http://blog.ifyouseewendy.com/blog/categories/books/atom.xml" rel="self"/>
  <link href="http://blog.ifyouseewendy.com/"/>
  <updated>2014-09-29T18:37:36+08:00</updated>
  <id>http://blog.ifyouseewendy.com/</id>
  <author>
    <name><![CDATA[wendi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Review] Rebuilding Rails]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2014/09/27/rebuilding-rails/"/>
    <updated>2014-09-27T14:48:48+08:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2014/09/27/rebuilding-rails</id>
    <content type="html"><![CDATA[<table class="custom">
  <tbody>
    <tr>
      <td><strong>Book</strong></td>
      <td>Rebuilding Rails</td>
    </tr>
    <tr>
      <td><strong>Author</strong></td>
      <td>Noah Gibbs</td>
    </tr>
    <tr>
      <td><strong>Link</strong></td>
      <td><a href="http://rebuilding-rails.com/">rebuilding-rails.com</a></td>
    </tr>
  </tbody>
</table>

<p>My re-building source code</p>

<ul>
  <li><a href="https://github.com/ifyouseewendy/rulers">rulers</a></li>
  <li><a href="https://github.com/ifyouseewendy/best_quotes">best_quotes</a></li>
</ul>

<p>Work flow diagram</p>

<p><img src="https://raw.githubusercontent.com/ifyouseewendy/best_quotes/master/rebuilding-rails.png" alt="img texrebuilding-rails" style="width:562px" /></p>

<h2 id="zero-to-it-works">1. Zero to “It Works!”</h2>

<p><code>ruby
gem.add_development_dependency "rspec"
gem.add_runtime_dependency "rest-client"
gem.add_runtime_dependency "some_gem", "1.3.0"
gem.add_runtime_dependency "other_gem", "&gt;0.8.2"
</code></p>

<p>Each of these adds a runtime dependency (needed to run the gem at all) or a development dependency (needed to develop or test the gem).</p>

<p>Youʼll need to go into the rulers directory and <code>git add .</code> before you rebuild the gem (<code>git add .; gem build rulers.gemspec; gem install rulers-0.0.1.gem</code>). Thatʼs because rulers.gemspec is actually calling git to find out what files to include in your gem.</p>

<p><strong>Rails structure</strong></p>

<ul>
  <li>
    <p><strong>ActiveSupport</strong> is a compatibility library including methods that aren’t necessarily specific to Rails. You’ll see ActiveSupport used by non-Rails libraries because it contains such a lot of useful baseline functionality. ActiveSupport includes methods like how Rails changes words from single to plural, or CamelCase to snake_case. It also includes significantly better time and date support than the Ruby standard library.</p>
  </li>
  <li>
    <p><strong>ActiveModel</strong> hooks into features of your models that aren’t really about the database - for instance, if you want a URL for a given model, ActiveModel helps you there. It’s a thin wrapper around many different ActiveModel implementations to tell Rails how to use them. Most commonly, ActiveModel implementations are ORMs (see ActiveRecord, below), but they can also use non-relational storage like MongoDB, Redis, Memcached or even just local machine memory.</p>
  </li>
  <li>
    <p><strong>ActiveRecord</strong> is an Object-Relational Mapper (ORM). That means that it maps between Ruby objects and tables in a SQL database. When you query from or write to the SQL database in Rails, you do it through ActiveRecord. ActiveRecord also implements ActiveModel. ActiveRecord supports MySQL and SQLite, plus JDBC, Oracle, PostgreSQL and many others.</p>
  </li>
  <li>
    <p><strong>ActionPack</strong> (<em>ActionDispatch, ActionController, Actionview</em>) does routing - the mapping of an incoming URL to a controller and action in Rails. It also sets up your controllers and views, and shepherds a request through its controller action and then through rendering the view. For some of it, ActionPack uses Rack. The template rendering itself is done through an external gem like Erubis for .erb templates, or Haml for .haml templates. ActionPack also handles action- or view-centered functionality like view caching.</p>
  </li>
  <li>
    <p><strong>ActionMailer</strong> is used to send out email, especially email based on templates. It works a lot like you’d hope Rails email would, with controllers, actions and “views” - which for email are text- based templates, not regular web-page templates.</p>
  </li>
</ul>

<h2 id="your-first-controller">2. Your First Controller</h2>

<p>Rails encapsulated the Rack information into a “request” object rather than just including the hash right into the controller. Thatʼs a good idea when you want to abstract it a bit – normalize values for certain variables, for instance, or read and set cookies to store session data.</p>

<h2 id="rails-automatic-loading">3. Rails Automatic Loading</h2>

<p>When debugging or printing error messages I like to use STDERR because itʼs a bit harder to redirect than a normal “puts” and so youʼre more likely to see it even when using a log file, background process or similar.</p>

<p>For simple structures, “inspect” shows them exactly as youʼd type them into Ruby – strings with quotes, numbers bare, symbols with a leading colon and so on.</p>

<p><strong>Reloading Means Convenience</strong></p>

<p><code>gem "rulers", :path =&gt; "../rulers"</code> This trick actually relies on deep Bundler trickery and requires you to always “bundle exec” before running things like rackup. If you forget that, it can look like the gem isnʼt there or (worse) look like an old version.</p>

<p><strong>CamelCase and snake_case</strong></p>

<p>```ruby
# rulers/lib/rulers/util.rb
module Rulers
  def self.to_underscore(string)
    string.gsub(/::/, ‘/’).
    gsub(/([A-Z]+)([A-Z][a-z])/,’\1<em>\2’).
    gsub(/([a-z\d])([A-Z])/,’\1</em>\2’).
    tr(“-“, “_”).
    downcase
  end
end</p>

<h1 id="httpcontroller---httpcontroller">‘HTTPController’ -&gt; ‘http_controller’</h1>
<p># ‘MD5Controller’ -&gt; ‘md5_controller’
# ‘HomeController’ -&gt; ‘home_controller’
```</p>

<p><strong>Put it together</strong></p>

<p><code>ruby
# rulers/lib/rulers/dependencies.rb
class Object
  def self.const_missing(c)
    require Rulers.to_underscore(c.to_s)
    Object.const_get(c)
  end
end
</code></p>

<p><code>ruby
# rulers/lib/rulers/controller.rb
def controller_name
  klass = self.class
  klass = klass.to_s.gsub /Controller$/, ""
  Rulers.to_underscore klass
end
</code></p>

<p><strong>Did it work?</strong></p>

<p>When you load a file called whatever_class.rb, youʼre not actually guaranteed that it contains WhateverClass, or that the constant WhateverClass is actually a class. How would you check?</p>

<p>You might try calling const_get(:WhateverClass)… Except that you just made const_get try to load automatically. If you call it on an unloaded class inside the method call where you try to load, youʼll recurse forever and get a “stack level too deep” and a crash. So const_get isnʼt the full answer.</p>

<p>```ruby
# rulers/lib/rulers/dependencies.rb
class Object
  def self.const_missing(c)
    return nil if @calling_const_missing</p>

<pre><code>@calling_const_missing = true
require Rulers.to_underscore(c.to_s)
klass = Object.const_get(c)
@calling_const_missing = false

klass   end end ```
</code></pre>

<p>But thereʼs a reason I say “hideously hacky.” Think about ways this could break. For instance – think about what would happen if you hit this in multiple threads at once. Oops!</p>

<p><strong>Re-re-reloading</strong></p>

<p><a href="https://github.com/alexch/rerun">rerun</a></p>

<p>```ruby
# best_quotes/Gemfile
source ‘https://rubygems.org’
gem ‘rulers’, :path =&gt; “../rulers”</p>

<p>group :development do
  gem ‘rerun’
  gem ‘listen’, ‘=1.3.1’ # for older Ruby
end
```</p>

<p>Running by <code>bundle exec rerun -- rackup -p 3001</code>. The “–” is an old Unix trick. It means “thatʼs all the arguments you get, the rest belong to somebody else.” Specifically, it tells rerun to ignore the “-p” later.</p>

<p><a href="https://github.com/rtomayko/shotgun">shotgun</a></p>

<p>reloading rack development server, forking version of rackup.</p>

<p><strong>In Rails</strong></p>

<ol>
  <li>
    <p><a href="https://github.com/rails/rails/blob/master/activesupport/lib/active_support/dependencies.rb">rails/activesupport/lib/active_support/dependencies.rb</a> Rails uses ActiveSupport for its const_missing support. Most of the code is installing a const_missing that can call through to non-Rails versions of const_missing in other classes, and can be removed or re-added and is appropriately modular. It also works hard to support nested modules like MyLibrary::SubModule::SomeClass.</p>
  </li>
  <li>
    <p><a href="http://urbanautomaton.com/blog/2013/08/27/rails-autoloading-hell/#fn1">Rails autoloading — how it works, and when it doesn’t</a> by Simon Coffey.</p>
  </li>
</ol>

<h2 id="rendering-views">4. Rendering Views</h2>

<p><strong>Erb and Erubis</strong></p>

<p>```ruby
# some_directory/erb_test.rb
require “erubis”</p>

<p>template = «TEMPLATE
Hello! This is a template.
It has &lt;%= whatever %&gt;.
TEMPLATE</p>

<p>eruby = Erubis::Eruby.new(template)
puts eruby.src
puts “==========”
puts eruby.result(:whatever =&gt; “ponies!”)
```</p>

<p>Run it with <code>ruby erb_test.rb</code></p>

<p><code>ruby
bash-3.2$ ruby erb_test.rb
_buf = ''; _buf &lt;&lt; 'Hello!   This is a template. It has ';
_buf &lt;&lt; ( whatever ).to_s; _buf &lt;&lt; '.';
_buf.to_s
==========
Hello! This is a template.
It has ponies!.
</code></p>

<p>The few lines starting with <code>_buf</code> are interesting. Erubis takes apart our string, appends it to <code>_buf</code> piece by piece, and adds the variables in as well after calling <code>.to_s</code> on them. Then it just returns <code>_buf</code>.</p>

<p><strong>Rack test example</strong></p>

<p><a href="https://github.com/brynary/rack-test">rack-test</a></p>

<p>```ruby
require_relative “test_helper”</p>

<p>class TestApp &lt; Rulers::Application
  def get_controller_and_action(env)
    [TestController, “index”]
  end
end</p>

<p>class TestController &lt; Rulers::Controlle
  def index
    “Hello!”  # Not rendering a view
  end
end</p>

<p>class RulersAppTest &lt; Test::Unit::TestCase
 include Rack::Test::Methods</p>

<p>def app
    TestApp.new
  end</p>

<p>def test_request
    get “/example/route”
    assert last_response.ok?
    body = last_response.body
    assert body[“Hello”]
  end
end
```</p>

<p><strong>Rake test example</strong></p>

<p>Rake actually ships with a “Rake::TestTask”.</p>

<p>```ruby
# Rakefile
require “bundler/gem_tasks”
require “rake/testtask”</p>

<p>Rake::TestTask.new do |t|
  t.name = “test”  # this is the default
  t.libs « “test”  # load the test dir
  t.test_files = Dir[‘test/<em>test</em>.rb’]
  t.verbose = true
end
```</p>

<p><em>A word of caution</em>: Rake will always run your tests by loading them into the same Ruby process, then running each one in turn. This is a lot faster than running them in individual processes, but it means that your tests can mess with each other in annoying ways. If you find yourself saying, “but I didnʼt set that global variable in this test!” think about whether some other test might have done it. For extra fun, the tests donʼt always run in any predictable order.</p>

<p><strong>In Rails</strong></p>

<p>Rails actually allows registering a number of different template engines at once with a number of different extensions so that Erb files are rendered with Erubis, but .haml files are rendered with the HAML templating engine.</p>

<p>You can find the top-level view code in <a href="https://github.com/rails/rails/blob/master/actionview/lib/action_view.rb">actionpack/lib/action_view.rb</a>, and the whole big chunk of Rails view code in actionpack/lib/action_view/. From there, look in <a href="https://github.com/rails/rails/blob/master/actionview/lib/action_view/template/handlers/erb.rb">template/handlers/erb.rb</a> for a pretty compact description of exactly how Rails uses Erubis to render Erb templates. You can see that most of the bulk of Railsʼ version is setup, interface and dealing with string encodings. You save a lot of trouble by knowing that youʼre basically only dealing with ASCII and/or UTF-8 strings.</p>

<h2 id="basic-models">5. Basic Models</h2>

<p>Use <a href="https://github.com/intridea/multi_json">multi_json</a> (a generic swappable back-end for JSON handling) to built a simple system of models based on JSON files.</p>

<p><strong>In Rails</strong></p>

<p>ActiveRecord is an Object-Relational Mapper so that each of your objects represents a database row. ActiveModel is the interface that Rails uses to all of storage including non-relational stores like Cassandra or MongoDB, to fit particular object types into Rails.</p>

<p>For a good overview of ActiveModel, have a look at a blog post from Yehuda Katz on that topic: <a href="http://yehudakatz.com/2010/01/10/activemodel-make-any-ruby-object-feel-like-activerecord/">ActiveModel: Make Any Ruby Object Feel Like ActiveRecord</a></p>

<h2 id="request-response">6. Request, Response</h2>

<p>```ruby
# rulers/lib/rulers/controller.rb
module Rulers
  class Controller
    def response(text, status = 200, headers = {})
      raise “Already responded!” if @response
      a = [text].flatten
      @response = Rack::Response.new(a, status, headers)
    end</p>

<pre><code>def get_response  # Only for Rulers
  @response
end

def render_response(*args)
  response(render(*args))
end   end end
</code></pre>

<h1 id="rulerslibrulersrb">rulers/lib/rulers.rb</h1>
<p>module Ruler
  class Application
    def call(env)   # Redefine
      if env[‘PATH_INFO’] == ‘/favicon.ico’
        return [404,
          {‘Content-Type’ =&gt; ‘text/html’}, []]
      end</p>

<pre><code>  klass, act = get_controller_and_action(env)
  controller = klass.new(env)
  text = controller.send(act)
  if controller.get_response
    # ensure the code after render_response works
    st, hd, rs = controller.get_response.to_a
    [st, hd, [rs.body].flatten]
  else
    # without explicitly render_response in action,
    # you can add auto render here
    [200, {'Content-Type' =&gt; 'text/html'}, [text]]
  end
end   end end ```
</code></pre>

<p>In Rails, the return value from the controller is ignored. Instead if you donʼt call render (Railsʼ equivalent of render_response), it will automatically call it for you with the same controller name, and the viewʼs name set to the same name as your action.</p>

<p>Rails doesnʼt return the string when you call “render” (well, usually - some calls to render do!). Instead, it keeps track of the fact that you called render and what you called it on. Then it gives you an error if you call it again, or uses the defaults if you get to the end of a controller action without calling it</p>

<p><strong>Instance Variables</strong></p>

<p>The Rails answer is to set instance variables in the controller, then use them in the view. Try creating a new view object, mostly just to use Erubis to evaluate the view file. Then, make it easy to pass in a hash of instance variables which youʼll set on the view object before doing the evaluation.</p>

<p><code>ruby
# rulers/lib/rulers/controller.rb
module Rulers
  class Controller
    def render(view_name, locals = {})
      filename = File.join 'app', 'views', controller_name, "#{view_name}.html.erb"
      ivars = instance_variables.reduce({}) {|ha, iv| ha[iv] = instance_variable_get(iv); ha }
      Rulers::View.new(filename, ivars, locals).result
    end
  end
end
</code></p>

<p><strong>In Rails</strong></p>

<p>Rails (more specifically, ActionPack) uses Rack in a very similar way, even exposing the Rack Request object with the “request” method. Especially <a href="https://github.com/rails/rails/blob/master/actionpack%2Flib%2Faction_controller%2Fmetal.rb">metal.rb </a>and metal/*.rb. “Rails Metal” is a name for the lower-level Rails which goes mostly straight through to the “bare metal” – that is, to Rack.</p>

<p>You can find a lot of the Rails implementation of Rack in these directories – for instance, metal/redirecting.rb is the implementation of the redirect_to() helper which returns status 302 (redirect) and a location to Rack. You could steal the code and add a redirect_to to Rulers, if you wanted.</p>

<p>You can also find things like forgery (CSRF) protection, multiple renderers (i.e. Erb vs Haml), forcing SSL if requested and cookies in this directory. Some are complex, while others call to Rack very simply and you could move right over to Rulers.</p>

<h2 id="the-littlest-orm">7. The Littlest ORM</h2>

<p>migration</p>

<p><code>ruby
# best_quotes/mini_migration.rb
require "sqlite3"
conn = SQLite3::Database.new "test.db"
conn.execute &lt;&lt;SQL
create table my_table (
  id INTEGER PRIMARY KEY,
  posted INTEGER,
  title VARCHAR(30),
  body VARCHAR(32000));
SQL
</code></p>

<p>sqlite model</p>

<p>```ruby
# rulers/lib/rulers/sqlite_model.rb
require “sqlite3”
require “rulers/util”</p>

<p>DB = SQLite3::Database.new “test.db”</p>

<p>module Rulers
  module Model
    class SQLite</p>

<pre><code>  class &lt;&lt; self
    def table
      Rulers.to_underscore name
    end

    def schema
      return @schema if @schema
      @schema = {}
      DB.table_info(table) do |row|
        @schema[ row['name'] ] = row['type']
      end
      @schema
    end

    def to_sql(val)
      case val
      when Numeric
        val.to_s
      when String
        "'#{val}'"
      else
        raise "Can't change #{val.class} to SQL!"
      end
    end

    def create(values)
      values.delete 'id'
      keys = schema.keys - ['id']
      vals = keys.map do |key|
        values[key] ? to_sql(values[key]) : 'null'
      end

      DB.execute &lt;&lt;SQL
        INSERT INTO #{table} (#{keys.join(',')})
        VALUES (#{vals.join(',')}); SQL

      data = Hash[keys.zip(vals)]
      sql = "SELECT last_insert_rowid();"
      data['id'] = DB.execute(sql)[0][0]
      self.new data
    end

    def count
      DB.execute(&lt;&lt;SQL)[0][0]
        SELECT COUNT(*) FROM #{table} SQL
    end

    def find(id)
      row = DB.execute &lt;&lt;SQL
        SELECT #{schema.keys.join(',')} from #{table} where id=#{id} SQL
      data = Hash[ schema.keys.zip row[0] ]
      self.new data
    end
  end

  def initialize(data = nil)
    @hash = data
  end

  def [](name)
    @hash[name.to_s]
  end

  def []=(name, value)
    @hash[name.to_s] = value
  end

  def save!
    unless @hash['id']
      self.class.create
      return true
    end

    fields = @hash.map do |k,v|
      "#{k}=#{self.class.to_sql(v)}"
    end.join(',')

    DB.execute &lt;&lt;SQL
      UPDATE #{self.class.table}
      SET #{fields}
      WHERE id="#{@hash['id']}" SQL
    true
  end

  def save
    save! rescue false
  end

end   end end ```
</code></pre>

<p>You can add a method to the SQLite model that takes a column name and a type, and then when saving and loading that column, does something type-dependent to it, like the boolean or JSON fields above.</p>

<p>ActiveRecord allows both ways – you can research the <code>before_save</code> and <code>after_initialize</code> callbacks for how to do it on save/ load.</p>

<p><strong>In Rails</strong></p>

<p>ActiveRecord contains mappings of operations like our gem, but also migrations, cross-database compatibility and a huge amount of optimization and general complexity. And thatʼs even though they use the ARel gem for most of the heavy lifting!</p>

<h2 id="rack-middleware">Rack Middleware</h2>

<p>With any Ruby web framework, you can modify how it works by adding Rack components around it. I like thinking of them as pancakes, because Rack lets you build your framework and your application like a stack of pancakes.</p>

<p><strong>Built-in middlewares</strong></p>

<ul>
  <li><strong>Rack::Auth::Basic</strong> - HTTP Basic authentication.</li>
  <li><strong>Rack::Auth::Digest</strong> - HTTP Digest authentication.</li>
  <li><strong>Rack::Cascade</strong> - Pass a request to a series of Rack apps, and use the first request that comes back as good. Itʼs a way to mount one Rack app “on top of” another (or many).</li>
  <li><strong>Rack::Chunked</strong> - A Rack interface to HTTP Chunked transfer.</li>
  <li><strong>Rack::CommonLogger</strong> - Request logging.</li>
  <li><strong>Rack::ConditionalGet</strong> - Implement HTTP If-None-Match and If- Modified-Since with ETags and dates.</li>
  <li><strong>Rack::Config</strong> - Call a given block before each request.</li>
  <li><strong>Rack::ContentLength</strong> - Set Content-Length automatically.</li>
  <li><strong>Rack::ContentType</strong> - Try to guess Content-Type and set it. Rack::Deflater - Compress the response with gzip/deflate.</li>
  <li><strong>Rack::Directory</strong> - Add Apache-style directory listings. This is an endpoint not an intermediate layer, so use it with “run.”</li>
  <li><strong>Rack::ETag</strong> - Generate ETags from MD5s of the content.</li>
  <li><strong>Rack::Head</strong> - Remove response body for HEAD requests.</li>
  <li><strong>Rack::Lint</strong> - Check your responses for correctness.</li>
  <li><strong>Rack::Lock</strong> - Only allow one thread in at once.</li>
  <li><strong>Rack::Reloader</strong> - Reload your app when files change.</li>
  <li><strong>Rack::Runtime</strong> - Times the request, sets X-Runtime in response.</li>
  <li><strong>Rack::Sendfile</strong> - Use the X-Sendfile header to ask your web server to send a file much faster than Ruby can.</li>
  <li><strong>Rack::ShowExceptions</strong> - Show a nice exception page if something breaks.</li>
  <li><strong>Rack::ShowStatus</strong> - Show a pretty page if the result is empty.</li>
  <li><strong>Rack::Static</strong> - Serve from certain directories as static files instead
of calling your framework.</li>
  <li><strong>Rack::URLMap</strong> - Route different directories to different apps or different stacks. You can also use this with a “map” block in config.ru.</li>
</ul>

<p>Rack::URLMap is a way to tell Rack what paths go to what Rack apps - and if thereʼs could be two that match, the longer path always takes precedence.</p>

<p>Rack::ContentType is to set the default HTML content type for everything. Since itʼs at the top, outside the blocks, it applies to all the blocks.</p>

<p>The lobster, by the way, is a simple test app built into Rack. Youʼll see it as an example in many places.</p>

<p><strong>Thrid-party middlewares</strong></p>

<ul>
  <li><a href="https://github.com/rack/rack-contrib">rack-contrib</a></li>
  <li><a href="https://github.com/rack/rack/wiki/List-of-Middleware">middlewares listed in rack wiki</a></li>
</ul>

<p><strong>In Rails</strong></p>

<p>The primary Rack application object in Rails is called ActionController::Dispatcher.</p>

<p>ActionController::Base allows you to get mini-Rack-apps for each controller action because it inherits from Metal, the basic Rails Rack class. So you can call MyController.action(:myaction) and get a Rack app for that action in your controller.</p>

<p><strong>Calling order of Rack middlewares</strong></p>

<p>```ruby
class Foo
  def initialize(app, arg = ‘’)
    puts ‘–&gt; Foo#init’
    @app = app
    @arg = arg
    puts ‘–&gt; Foo#initend’
  end</p>

<p>def call(env)
    puts ‘–&gt; Foo#call’
    status, headers, content = @app.call(env)
    content[0] += “#{@arg}”
    puts ‘–&gt; Foo#callend’
    [ status, headers, content ]
  end
end</p>

<p>class Bar
  def initialize(app, arg = ‘’)
    puts ‘–&gt; Bar#init’
    @app = app
    @arg = arg
    puts ‘–&gt; Bar#initend’
  end</p>

<p>def call(env)
    puts ‘–&gt; Bar#call’
    status, headers, content = @app.call(env)
    content[0] += “#{@arg}”
    puts ‘–&gt; Bar#callend’
    [ status, headers, content ]
  end
end</p>

<p>use Foo, ‘, foo’
use Bar, ‘, bar’</p>

<p>run proc {
  puts ‘–&gt; main#call’
  [200, {‘Content-Type’ =&gt; ‘text/html’}, [‘Hello, world’]]
}</p>

<h1 id="rackup">$ rackup</h1>
<p># –&gt; Bar#init
# –&gt; Bar#initend
# –&gt; Foo#init
# –&gt; Foo#initend
# Thin web server (v1.6.1 codename Death Proof)
# Maximum connections set to 1024
# Listening on 0.0.0.0:9292, CTRL+C to stop
#
# –&gt; Foo#call
# –&gt; Bar#call
# –&gt; main#call
# –&gt; Bar#callend
# –&gt; Foo#callend
# 127.0.0.1 - wendi [23/Sep/2014 15:56:20] “GET / HTTP/1.1” 200 - 0.0013
```</p>

<p>Other samples:</p>

<ul>
  <li><a href="https://gist.github.com/ifyouseewendy/15dd511d2d939e432068#file-config-lobster-ru">lobster</a></li>
  <li><a href="https://gist.github.com/ifyouseewendy/15dd511d2d939e432068#file-config-auth-ru">auth</a></li>
  <li><a href="https://gist.github.com/ifyouseewendy/15dd511d2d939e432068#file-config-benchmark-ru">benchmark</a></li>
</ul>

<h2 id="real-routing">9. Real Routing</h2>

<p>Rails 3 takes this a half-step farther and makes every action on every controller a full-on Rack app that you can extract and use.</p>

<p>Add RouteObject class.</p>

<p>```ruby
class RouteObject
  def initialize
    @rules = []
  end</p>

<p># save routing rules
  def match(url, *args)
    options = {}
    options = args.pop if args[-1].is_a?(Hash)
    options[:default] ||= {}</p>

<pre><code>dest = nil
dest = args.pop if args.size &gt; 0
raise 'Too many args!' if args.size &gt; 0

parts = url.split('/')
parts.select!{|p| !p.empty? }

vars = []
regexp_parts = parts.map do |part|
  if part[0] == ':'
    vars &lt;&lt; part[1..-1]
    "([a-zA-Z0-9_]+)"
  elsif part[0] == '*'
    vars &lt;&lt; part[1..-1]
    "(.*)"
  else
    part
  end
end

regexp = regexp_parts.join('/')
@rules.push({
  :regexp =&gt; Regexp.new("^/#{regexp}$"),
  :vars =&gt; vars,
  :dest =&gt; dest,
  :options =&gt; options
})   end
</code></pre>

<p># match rules to url and route to specific controller action.
  # 
  # 1. the router just applies them in order – if more than
  #    one rule matches, the first one wins.
  # 2. the second argument can be a Rack application, 
  #    which Rails then calls.
  def check_url(url)
    @rules.each do |r|
      m = r[:regexp].match(url)</p>

<pre><code>  if m
    options = r[:options]
    params = options[:default].dup

    r[:vars].each_with_index do |v, i|
      params[v] = m.captures[i]
    end

    if r[:dest]
      return get_dest(r[:dest], params)
    else
      controller = params['controller']
      action = params['action']
      return get_dest("#{controller}##{action}", params)
    end
  end
end

nil   end
</code></pre>

<p>def get_dest(dest, routing_params = {})
    return dest if dest.respond_to?(:call)</p>

<pre><code>if dest =~ /^([^#]+)#([^#]+)$/
  name = $1.capitalize
  cont = Object.const_get("#{name}Controller")
  return cont.action($2, routing_params)
end

raise "No destination: #{dest.inspect}!"   end end ```
</code></pre>

<p>Define <code>route</code> to save rules in an instance of RouteObject, and use <code>get_rack_app</code> to route to controller actions. </p>

<p>```ruby
module Rulers
  class Application
    def route(&amp;block)
      @route_obj ||= RouteObject.new
      @route_obj.instance_eval(&amp;block)
    end</p>

<pre><code>def get_rack_app(env)
  raise 'No routes!' unless @route_obj
  @route_obj.check_url env['PATH_INFO']
end   end end ```
</code></pre>

<p>Update Rulers::Controller to use <code>self.action</code> to initialize rack app, and <code>dispatch</code> to specific action.</p>

<p>```ruby
# rulers/lib/rulers/controller.rb
module Rulers
  class Controller
    include Rulers::Model</p>

<pre><code>def initialize(env)
  @env = env
  @routing_params = {}
end

def env
  @env
end

def self.action(act, p = {})
  proc {|e| self.new(e).dispatch(act, p) }
end

def dispatch(action, routing_params = {})
  @routing_params = routing_params

  self.send(action)
  render_response action.to_sym unless get_response
  st, hd, rs = get_response.to_a
  [st, hd, [rs.body].flatten]
end

def params
  request.params.merge @routing_params
end
</code></pre>

<p>end
end
```</p>

<p><strong>In Rails</strong></p>

<p>Rails connects lots of tiny Rack applications into a single overall application. Itʼs a complicated, multi-layered construction.</p>

<p>Each Rails controller keeps track of a mini-Rack stack of middleware which can be specified per-action like before_filters.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Review] Git Community Book]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2014/09/27/git-community-book/"/>
    <updated>2014-09-27T13:51:25+08:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2014/09/27/git-community-book</id>
    <content type="html"><![CDATA[<table class="custom">
  <tbody>
    <tr>
      <td><strong>Book</strong></td>
      <td>Git Community Book</td>
    </tr>
    <tr>
      <td><strong>Author</strong></td>
      <td>people in the Git community</td>
    </tr>
    <tr>
      <td><strong>Link</strong></td>
      <td><a href="http://alx.github.io/gitbook/">alx.github.io/gitbook</a></td>
    </tr>
  </tbody>
</table>

<h2 id="git-object-model">Git Object Model</h2>

<h3 id="the-sha">The SHA</h3>

<ol>
  <li>Represents object name.</li>
  <li>40-digit long.</li>
  <li>Use SHA1 hash to generate based on the object content.</li>
  <li>Keeps the identity.</li>
</ol>

<h3 id="the-objects">The Objects</h3>

<p>Every object consists of three things: <strong>type, size, content</strong>.</p>

<p>There are four different types of objects: <strong>blob, tree, commit, tag</strong>.</p>

<p><strong>blob</strong> is a chunk of binary data, used to stroe file data.</p>

<blockquote>
  <p>The blob is entirely defined by its data, totally independent of its location.</p>
</blockquote>

<p><strong>tree</strong> is basically like a directory - it references a bunch of other trees and/or blobs.</p>

<blockquote>
  <p>Since trees and blobs, like all other objects, are named by the SHA1 hash of their contents, two trees have the same SHA1 name if and only if their contents (including, recursively, the contents of all subdirectories) are identical.</p>
</blockquote>

<p><strong>commit</strong>  points to a single tree, marking it as what the project looked like at a certain point in time. It contains meta-information about that point in time, such as a timestamp, the author of the changes since the last commit, a pointer to the previous commit(s), etc.</p>

<p>```sh
➜  git show –pretty=raw HEAD
commit 6cc1a668111eb54ef4dbe976fff24f2e3d8b95f9
tree 36df675d7ae80e7eef0faac893b266801a4fa94a
parent d448c30aa03fba2884ab87c21081ef0f74d24f7e
author wendi <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#119;&#101;&#110;&#100;&#105;&#064;&#117;&#109;&#101;&#110;&#103;&#046;&#099;&#111;&#109;">&#119;&#101;&#110;&#100;&#105;&#064;&#117;&#109;&#101;&#110;&#103;&#046;&#099;&#111;&#109;</a> 1409022714 +0800
committer wendi <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#119;&#101;&#110;&#100;&#105;&#064;&#117;&#109;&#101;&#110;&#103;&#046;&#099;&#111;&#109;">&#119;&#101;&#110;&#100;&#105;&#064;&#117;&#109;&#101;&#110;&#103;&#046;&#099;&#111;&#109;</a> 1409022733 +0800</p>

<pre><code>Update error type service url ```
</code></pre>

<p><strong>tag</strong> is a way to mark a specific commit as special in some way. It is normally used to tag certain commits as specific releases or something along those lines.</p>

<blockquote>
  <p>A tag object contains an object name (called simply ‘object’), object type, tag name, the name of the person (“tagger”) who created the tag, and a message, which may contain a signature</p>
</blockquote>

<h3 id="different-from-svn">Different from SVN</h3>

<p>GIT stores a snapshot, while other SCM systems stores the differences between one commit and the next.</p>

<h2 id="advanced-git">Advanced Git</h2>

<h3 id="create-new-empty-branches">Create New Empty Branches</h3>

<p>Use <strong>symobolic-ref</strong>. A symbolic ref is a regular file that stores a string that begins with ref: refs/. For example, your .git/HEAD is a regular file whose contents is ref: refs/heads/master.</p>

<blockquote>
  <p>In the past, .git/HEAD was a symbolic link pointing at
       refs/heads/master. When we wanted to switch to another branch, we did
       ln -sf refs/heads/newbranch .git/HEAD, and when we wanted to find out
       which branch we are on, we did readlink .git/HEAD. But symbolic links
       are not entirely portable, so they are now deprecated and symbolic refs
       (as described above) are used by default.</p>
</blockquote>

<p><code>sh
$ git symbolic-ref HEAD refs/heads/newbranch
  # no branch is created,
  # and all files are deleted to index.
$ rm .git/index
git clean -fdx
&lt;do work&gt;
git add your files
git commit -m 'Initial commit'
  # branch 'newbranch' is created.
</code></p>

<h3 id="modifying-your-history">Modifying Your History</h3>

<p>use <code>git filter-branch</code> to rewrite branches.</p>

<h3 id="advanced-merging">Advanced Merging</h3>

<p>When merging, one parent will be <strong>HEAD</strong>, and the other will be the tip of the other branch, which is stored temporarily in <strong>MERGE_HEAD</strong>.</p>

<p>During the merge, the index holds three versions of each file. Each of these three “file stages” represents a different version of the file:</p>

<p><code>sh
$ git show :1:file.txt # the file in a common ancestor of both branches.
$ git show :2:file.txt # the version from HEAD.
$ git show :3:file.txt # the version from MERGE_HEAD.
</code></p>

<p>Some special diff options allow diffing the working directory against any of these stages:</p>

<p><code>sh
$ git diff -1 file.txt # diff against stage 1
$ git diff --base file.txt # same as the above
$ git diff -2 file.txt # diff against stage 2
$ git diff --ours file.txt # same as the above
$ git diff -3 file.txt # diff against stage 3
$ git diff --theirs file.txt # same as the above.
</code></p>

<h3 id="git-and-email">Git and Email</h3>

<p><code>sh
$ man git-format-patch # Prepare patches for email submission
$ man git-am # Apply a series of patches from a mailbox
</code></p>

<p><code>git format-patch origin</code> will produce a numbered series of files in the current directory, one of each patch in the current branch but not in origin/HEAD.</p>

<p><code>git am patches.mbox</code></p>

<h3 id="client-side-hookds">Client Side Hookds</h3>

<p>by example, <code>GIT_DIR/hooks/pre-commit</code></p>

<h3 id="submodules">Submodules</h3>

<p>Create the submodules:</p>

<p><code>sh
$ mkdir ~/git
$ cd ~/git
$ for i in a b c d
do
    mkdir $i
    cd $i
    git init
    echo "module $i" &gt; $i.txt
    git add $i.txt
    git commit -m "Initial commit, submodule $i"
    cd ..
done
</code></p>

<p>Create the superproject and add all the submodules:</p>

<p><code>sh
$ mkdir super
$ cd super
$ git init
$ for i in a b c d
do
    git submodule add ~/git/$i
done
</code></p>

<p>See what files git-submodule created:</p>

<p><code>sh
$ ls -a
.  ..  .git  .gitmodules  a  b  c  d
</code></p>

<p>The <code>git-submodule add</code> command does a couple of things:</p>

<ul>
  <li>It clones the submodule under the current directory and by default checks out the master branch.</li>
  <li>It adds the submodule’s clone path to the gitmodules file and adds this file to the index, ready to be committed.</li>
  <li>It adds the submodule’s current commit ID to the index, ready to be committed.</li>
</ul>

<p>Commit the superproject:</p>

<p><code>sh
$ git commit -m "Add submodules a, b, c and d."
</code></p>

<p>Clone the superproject:</p>

<p><code>sh
$ cd ..
$ git clone super cloned
$ cd cloned
</code></p>

<p>Check submodule status:</p>

<p><code>sh
$ git submodule status
-d266b9873ad50488163457f025db7cdd9683d88b a
-e81d457da15309b4fef4249aba9b50187999670d b
-c1536a972b9affea0f16e0680ba87332dc059146 c
-d96249ff5d57de5de093e6baff9e0aafa5276a74 d
</code></p>

<p>Register the submodule into <code>.git/config</code>:</p>

<p><code>sh
$ git submodule init
</code></p>

<p>Clone the submodules and check out the commits specified in the superproject:</p>

<p><code>sh
$ git submodule update
$ cd a
$ ls -a
.  ..  .git  a.txt
</code></p>

<p>One major difference between <code>git-submodule update</code> and <code>git-submodule add</code> is that git-submodule update checks out a specific commit, rather than the tip of a branch. It’s like checking out a tag: <strong>the head is detached</strong>, so you’re not working on a branch.</p>

<p><code>sh
$ git branch
* (no branch)
master
</code></p>

<p>Check out or create a new branch:</p>

<p><code>sh
$ git checkout master
</code></p>

<p><code>sh
$ git checkout -b fix-up
</code></p>

<p>Do work and commit:</p>

<p><code>sh
$ echo "adding a line again" &gt;&gt; a.txt
$ git commit -a -m "Updated the submodule from within the superproject."
$ git push
$ cd ..
$ git diff
diff --git a/a b/a
index d266b98..261dfac 160000
--- a/a
+++ b/a
@@ -1 +1 @@
-Subproject commit d266b9873ad50488163457f025db7cdd9683d88b
+Subproject commit 261dfac35cb99d380eb966e102c1197139f7fa24
$ git add a
$ git commit -m "Updated submodule a."
$ git push
</code></p>

<p><strong>Cautions on Submodules</strong>:</p>

<p><em>Always publish the submodule change before publishing the change to the superproject that references it. If you forget to publish the submodule change, others won’t be able to clone the repository:</em></p>

<p><code>sh
$ cd ~/git/super/a
$ echo i added another line to this file &gt;&gt; a.txt
$ git commit -a -m "doing it wrong this time"
$ cd ..
$ git add a
$ git commit -m "Updated submodule a again."
$ git push
$ cd ~/git/cloned
$ git pull
$ git submodule update
error: pathspec '261dfac35cb99d380eb966e102c1197139f7fa24' did not match any file(s) known to git.
Did you forget to 'git add'?
Unable to checkout '261dfac35cb99d380eb966e102c1197139f7fa24' in submodule path 'a'
</code></p>

<p><em>It’s not safe to run git submodule update if you’ve made and committed changes within a submodule without checking out a branch first. They will be silently overwritten</em>:</p>

<p><code>sh
$ cat a.txt
module a
$ echo line added from private2 &gt;&gt; a.txt
$ git commit -a -m "line added inside private2"
$ cd ..
$ git submodule update
Submodule path 'a': checked out 'd266b9873ad50488163457f025db7cdd9683d88b'
$ cd a
$ cat a.txt
module a
</code></p>

<h2 id="internals-and-plumbing">Internals and Plumbing</h2>

<h3 id="how-git-stores-objects">How Git Stores Objects</h3>

<p><strong>Loose objects</strong> are the simpler format. It is simply the compressed data stored in a single file on disk.</p>

<p>If the sha of your object is <code>ab04d884140f7b0cf8bbf86d6883869f16a46f65</code>, then the file will be stored in the following path:</p>

<p><code>sh
GIT_DIR/objects/ab/04d884140f7b0cf8bbf86d6883869f16a46f65
</code></p>

<p>The Ruby implementation of object storage:</p>

<p>```ruby
def put_raw_object(content, type)
  size = content.length.to_s</p>

<p>header = “#{type} #{size}#body”
  store = header + content</p>

<p>sha1 = Digest::SHA1.hexdigest(store)
  path = @git_dir + ‘/’ + sha1[0…2] + ‘/’ + sha1[2..40]</p>

<p>if !File.exists?(path)
    content = Zlib::Deflate.deflate(store)</p>

<pre><code>FileUtils.mkdir_p(@directory+'/'+sha1[0...2])
File.open(path, 'w') do |f|
  f.write content
end   end   return sha1 end ```
</code></pre>

<p><strong>Packed Objects</strong>. In order to save that space, Git utilizes the packfile. This is a format where Git will only save the part that has changed in the second file, with a pointer to the file it is similar to.</p>

<h3 id="the-git-index">The Git Index</h3>

<p>The index is a binary file (generally kept in .git/index) containing a sorted list of path names.</p>

<p><code>sh
$ git ls-files --stage
100644 63c918c667fa005ff12ad89437f2fdc80926e21c 0
100644 5529b198e8d14decbe4ad99db3f7fb632de0439d 0
100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 0
100644 a37b2152bd26be2c2289e1f57a292534a51a93c7 0
100644 fbefe9a45b00a54b58d94d06eca48b03d40a50e0 0
...
100644 2511aef8d89ab52be5ec6a5e46236b4b6bcd07ea 0
100644 2ade97b2574a9f77e7ae4002a4e07a6a38e46d07 0
100644 d5de8292e05e7c36c4b68857c1cf9855e3d2f70a 0
.gitignore
.mailmap
COPYING
Documentation/.gitignore
Documentation/Makefile
xdiff/xtypes.h
xdiff/xutils.c
xdiff/xutils.h
</code></p>

<ol>
  <li>
    <p>The index contains all the information necessary to generate a single (uniquely determined) tree object.</p>
  </li>
  <li>
    <p>The index enables fast comparisons between the tree object it defines and the working tree.</p>
  </li>
  <li>
    <p>It can efficiently represent information about merge conflicts between different tree objects.</p>
  </li>
</ol>

<h3 id="the-packfile-index">The Packfile Index</h3>

<p>Stored in <code>.git/objects/pack</code>.</p>

<p>Importantly, packfile indexes are not neccesary to extract objects from a packfile, they are simply used to quickly retrieve individual objects from a pack.</p>

<h3 id="raw-git">Raw Git</h3>

<p><strong>Creating Blobs</strong></p>

<p><code>sh
$ git hash-object -w myfile.txt
6ff87c4664981e4397625791c8ea3bbb5f2279a3
</code></p>

<p><strong>Creating Trees</strong></p>

<p>use <code>git mktree</code>.</p>

<p><strong>Creating Commits</strong></p>

<p>use <code>git commit-tree</code>.</p>

<p><strong>Updating a Branch Ref</strong></p>

<p><code>sh
$ echo 'a5f85ba5875917319471dfd98dfc636c1dc65650' &gt; .git/refs/heads/master
</code></p>

<p>a safer way of doing that is to use the <code>git update-ref</code> command:</p>

<p><code>sh
$ git update-ref refs/heads/master a5f85ba5875917319471dfd98dfc636c1dc65650
</code> </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Review]  历史深处的忧虑]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2014/09/23/lin-da-li-shi-shen-chu-de-you-lu/"/>
    <updated>2014-09-23T22:25:49+08:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2014/09/23/lin-da-li-shi-shen-chu-de-you-lu</id>
    <content type="html"><![CDATA[<table class="custom">
  <tbody>
    <tr>
      <td><strong>Book</strong></td>
      <td>历史深处的忧虑</td>
    </tr>
    <tr>
      <td><strong>Author</strong></td>
      <td>林达</td>
    </tr>
    <tr>
      <td><strong>Link</strong></td>
      <td><a href="http://book.douban.com/subject/25708714/">book.douban.com/subject/25708714</a></td>
    </tr>
  </tbody>
</table>

<p>中国人的“虐待”概念，带有很强的主观性和主动性。但是在美国，这只是一个法律概念，它是不考虑冬季，只察看行为和后果的。</p>

<h2 id="section">关于雇佣关系</h2>

<p>1964年的民权法。六十年代的美国民权运动的结果不仅是立法取消了种族隔离，它还使得自由派思潮广为流行。保护每一个人的平等权利的观念浮到了表层上，尤其是社会上的弱势群体，比如少数民族、妇女、残疾人等等，他们的权利受到了前所未有的关注。</p>

<p>1972年美国又制定了著名的平权法案，更规定了所有的政府机构和超过十五名雇员的私人企业，都必须在招工、技术培训、升迁等机会上，给弱势群体一定的比例。</p>

<p>1991年，美国再一次制定新的民权法案。把雇主和雇员在发生民权官司时，提供证据的负担重新放到雇主一边。</p>

<h2 id="section-1">关于权利法案</h2>

<p>我们在评论一件事情”好“还是”不好“的时候，他们经常只是简单地说：”这是合法的“以及“这是非法的”。</p>

<p>宪法确立了一个民主制度，宪法的修正案，尤其这个修正案的前十条，通常被称为权利法案的，保证了美国每一个”个人“最基本的权利不受侵犯。美国人认为，<strong>假如一个人最基本的权利能够得到保障，他就是自由的。</strong></p>

<p>1773年签署《独立宣言》，但是直到1783年，他们才打胜了这场以“生命、自由和追求幸福”的名义而举行的战争，英国终于签字承认了美国的独立。</p>

<p>《权利法案》旨在限制联邦政府权利的无限扩张，防止联邦政府干涉和剥夺美国人民的自由。从此宪法所支撑的美国变成了一个设计精巧的结构，政府和人民时时处于相互制约的状态之中。这个运转结构也是美国稳定的原因之一：政府时时处于强有力的监督之下，它就不容易在错误的道路上走得太远，甚至发生大滑坡；同时，人民有了充分的自由，他们有了表达意愿的渠道以及宣泄情绪的出口，也就不容易积怨之深从而产生爆发性的破坏力。</p>

<p>到1789年，美国宪法的前一部分才被通过。也就是说，美国打赢独立战争的六年之后，美国人法定的建国日十三年之后，美国政府才开始工作，才开始通过民主选举，选出他们的第一届总统华盛顿。</p>

<p>很多国家的宪法都有言论自由这一条，那么美国的《权利法案》有什么特殊的地方呢？它的特点就是规定了政府不得立法剥夺这种自由。</p>

<h2 id="section-2">关于第一修正案</h2>

<p>宪法第一修正案的关键就是：言论自由与真理完全无关。</p>

<p>马丁·路德·金认为“手段代表了在形成之中的理想和在进行之中的目的，人们无法通过邪恶的手段来达到美好的目的，因为手段是种子，目的是树”。</p>

<p>如何解决既维护言论自由的承诺，又惧怕言论引起的非法行为以及煽动暴力，甚至担心危及国家安全？</p>

<p>“清楚与现实的危险”测定原则。如果政府无法证明某一言论是造成了清楚与现实的危险，它就不能对该言论的发表者进行惩罚。</p>

<p>1969年重新规定了该原则：只有当一个言论所宣传的暴力，有可能直接煽起“迫在眉睫“的非法行动时，政府才有权干预。</p>

<p>我认为应该从教育中学习，不应该抑制任何声音。从最反面的人那里我也学到过东西。我可以不赞成某一观点，但是这并不意味着这一观点就不应该发表，或者说，我就不应该去听。</p>

<p>应该给三K党言论自由吗？斯蒂芬·潘佛回答到“如果你因为害怕一个不自由的时代，因此就不给他们言论自由的话，那么，这个不自由的时代已经开始了。是你自己给它开了头。”</p>

<p><strong>言论自由的关键是什么呢？</strong></p>

<p>关键就在于它的“内容中性“原则，就是要把“真理”二字坚决地摒弃在言论自由的大门之外。只要让“真理”二字一不小心从门缝里溜进来，言论自由就完了。为什么这样说呢？呼吁和宣扬言论自由的人们是很容易上“真理”的当的。他们或是明确认为，或是在潜意识中，总是觉得言论自由是走向“真理”的一条“阳光大道”，觉得言论自由只是让真理“越辩越明”的一种方式。在这种概念的指导下，一旦走到自己感觉已经“真理到手”的这一步，言论自由被抛弃就成了十分顺理成章的事儿。只要不坚持“内容中性”，只要以为言论自由的目的是为了追求真理，那么，就无法避免这样的情况发生：终有一日，在理论和现实上，都无法阻挡一个或数个权威在手的人物，或是一群所谓的“大多数”，出来把自己宣布为“真理”，而扼杀别人的言论自由。</p>

<p>克林顿对于俄克拉荷马爆炸案的一句评价：“这是针对美国，我们的生活方式以及我们所有信仰的攻击。”</p>

<p>政府的权利大，人民的权利必定受影响；政府的权利小，法律和秩序又不好保障。</p>

<p>分权，是横向把政府的权利切成两个大的层次，也就是把联邦政府和地方政府的权利分隔开。除了权利的横向分隔，宪法还把国家政府的权利从竖向切成三条，“三权分立”，立法（国会）、行政（总统）、司法（最高法院）的绝对独立。</p>

<p>“伟大的妥协”：国会的众议院以州人口比例确定议员的数量，而参议院则不论州的大小，每州两名议员，以确认小州的利益也有保障。</p>

<p>总统四年选一次，众议员两年选一次，参议员六年选一次。</p>

<p>最高法院的组成是九名大法官。这九名大法官由总统提名、经国会批准任命的，并且最高法院的大法官是终身制的。</p>

<p>新闻监督，免预检制度，由麦当娜催生出五秒滞后的预检限制。</p>

<p>新闻自由的主要意图就是防止对出版社的预先限制。即使是对于滥用新闻出版自由的人，也只能在事后，即出版之后适当惩罚，而不能预先阻止出版。</p>

<p>蒙哥马利市专管警察部门的一名政府官员，名叫沙利文，以诽谤罪告《纽约时报》和四名黑人牧师。由此，最高法院宣布了一条非常重要的原则：当公职人员遇到不实的批评而受到伤害的时候，他不能以诽谤罪要求赔偿金，除非他能够提出证据，证明这是出于“真是的恶意”。法庭同时也指出：在自由辩论中，发生失误是不可避免的，必须保护新闻界有“喘气的空间”，使他们有可能生存下去。</p>

<p>之后这条原则从“公职人员”扩大到了“公众人物”，而后再扩大到“卷入公众事务”的普通人。</p>

<h2 id="section-3">关于第二修正案</h2>

<p>保障了人民拥有枪的自由及保卫自由的能力。</p>

<p>在这个成分复杂的世界里，永远会有一部分人滥用自由。整个社会也就不得不为这种滥用自由的情况承担后果。</p>

<p>“二战”之前德国人民也是合法拥有武器的。但是在希特勒上台之后，首先搞枪支登记，然后设法逐步搞没收枪支。接着，犹太人面对武装的党卫队员，就只有束手待毙的份了。</p>

<h2 id="section-4">关于第三、四修正案</h2>

<p>私人财产不受侵犯是宪法第四修正案所保护的自由。</p>

<p>根据宪法第四修正案，最高法院早就有了“排斥原则”，这个原则认定，任何非法搜查的证据，都不能用于审理过程，任何在这个基础上的定罪都必须撤销。</p>

<p>在美国，所有人都知道，一个案子以胜诉终结，就是意味着另一个案子的开始。这非常有效地防止了美国政府的公职人员对平民的迫害，因为他们必须有所顾忌，一不当心的话，弄不好就是“搬起石头砸自己的脚”。</p>

<p>在这里发生一个民权案例的时候，各种民权机构以及许多平民，他们都会抛开对当事人个人的好恶，抛开对他的信念、言论、行为的好恶，去支持这个当事人保护自己的宪法权利。这个时候，他们看上去像是在共同守护一个堤坝，似乎一旦决堤就会一毁俱毁。</p>

<h2 id="section-5">关于第五、六、七修正案</h2>

<p>陪审团、审判相关。</p>

<p>“无罪假定”在美国的司法制度中是极为重要的一条。正是这一条，决定了检方和辩方从道义上的平等地位。正因为在审判之前，假定被告是无罪的，律师也就可以毫无心理负担，理直气壮的进行辩护。</p>

<p>如果检察官有任何抬高自己在道义上地位的迹象，比如说，宣称自己是伸张正义，而暗示辩护律师是为犯罪开脱等等，都是违反了“公平游戏”的原则，是严重犯规的行为。</p>

<p>警察的违规破案是否可行？《权利法案》的核心就是防止美国政府剥夺人民的自由和权力，如果以“成败论英雄”，那岂不是鼓励警察违反宪法。</p>

<p>陪审员被允许知道的东西，只限于法官判定可以让他们听到和看到的东西。</p>

<p>法官一般判定哪些“犯规”？与案情无关；还有一些诱导性的问题也是不允许的（不能先确定一个事实，问证人是不是这样）</p>

<p>提问的一方是在与证人对话，“抗议”的一方是在与法官对话，检辩双方一般是互相不对话的。一旦出现他们之间的对话，通常带有“争执”意味，法官会在这样的“苗子”刚刚冒出来的时候就马上叫停，有时会立即判处罚款。</p>

<p>在向证人提问时，也绝对不允许“争执”。与证人的全部对话只能以提问的形式出现。即使提问的一方发现证人明显是在那里说谎，他也不能直接对证人说，你这是说谎，因为这不仅已经不是“提问”，而且是一种“争执”。（所有律师都要有把肯定句变为疑问句的本事）</p>

<p>刑事法律有一个极其重要的原则，被告只要提出怀疑即可，不必作出证明，这叫做“没有证明的负担”；而相反，检方则必须提供证明以“超越合理的怀疑”，这叫做“具有证明的负担”，或者说“证明的负担在检方”。</p>

<p>不论陪审团最后作出什么样的裁决，是“罪名成立”也罢，是“罪名不成立”也罢，都必须是陪审团全体陪审员一致的意见。只要是意见不能取得一致，就意味着“无法做出裁决”，就必须宣判这一次的审判“宣告失败”。</p>

<p>在录音被公布之后，佛曼只引用了《权利法案》第五条中的一句话，就是人民“不得被强迫在任何刑事案件中自证其罪”。这一句也被扩大为：不能强迫一个人说出对自己不利的证词。</p>

<p>牺牲任何一个“个人”的自由权利以及家庭幸福，以此作为换取社会利益的代价，这种做法的合理性是不被美国宪法精神所承认的。它不承认任何一种社会要求可以高于一个公民对于自由幸福和合法权利的要求。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Review] Metaprogramming Ruby]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2014/06/03/metaprogrammingi-ruby/"/>
    <updated>2014-06-03T00:44:28+08:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2014/06/03/metaprogrammingi-ruby</id>
    <content type="html"><![CDATA[<table class="custom">
  <tbody>
    <tr>
      <td><strong>Book</strong></td>
      <td>Metaprogramming Ruby 2: Program Like the Ruby Pros</td>
    </tr>
    <tr>
      <td><strong>Author</strong></td>
      <td>Paolo Perrotta</td>
    </tr>
    <tr>
      <td><strong>Link</strong></td>
      <td><a href="https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2">pragprog.com/book/ppmetr2/metaprogramming-ruby-2</a></td>
    </tr>
  </tbody>
</table>

<h1 id="the-object-model">The Object Model</h1>

<p><img src="https://dl.dropboxusercontent.com/s/a6qc1yd1cd57pkp/the_object_model.png?dl=1&amp;token_hash=AAEBXb4OJ73P3xWWbPmIMOferP8_YHxQlS9d8l0hjEq2wQ&amp;expiry=1400078501" alt="the_object_model" /></p>

<p>An object contains its instance variables and a reference to a class.</p>

<h2 id="instance-variable">Instance variable</h2>

<p>Instance variables just spring into existence when you assign them a value, so you can have objects of the same class that carry different instance variables.</p>

<h2 id="instance-method">Instance method</h2>

<p>You can get a list of an object’s methods by calling <code>Object#methods</code>.</p>

<p>When you talk about the class, you call it an instance method, and when you talk about the object, you simply call it a method.</p>

<p><code>ruby
String.instance_methods == "abc".methods # =&gt; true
String.methods == "abc".methods # =&gt; false
</code></p>

<p>An object’s instance variables live in the object itself, and an object’s methods live in the object’s class. That’s why objects of the same class share methods but don’t share instance variables.</p>

<h2 id="truth-about-classes">Truth about classes</h2>

<p>The truth about classes: classes themselves are nothing but objects.</p>

<p>The methods of an object are also the instance methods of its class. In turn, this means that the methods of a class are the instance methods of <code>Class</code>:</p>

<p><code>ruby
Class.instance_methods(false) # =&gt; [:allocate, :new, :superclass]
</code></p>

<p><strong><em>What’s the difference between <code>class</code> and <code>superclass</code>?</em></strong></p>

<ul>
  <li><code>class</code> is about the type which an object belongs to.</li>
  <li><code>superclass</code> is about inheritance, between classes.</li>
</ul>

<p>The <code>superclass</code> of Class is Module—which is to say, every class is also a module. To be precise, a class is a module with three additional instance methods (new, allocate, and superclass) that allow you to create objects or arrange classes into hierarchies.</p>

<p><strong><em>Which to pick between Class and Module?</em></strong></p>

<p>Usually, you pick a module when you mean it to be included somewhere, and you pick a class when you mean it to be instantiated or inherited.</p>

<p><strong><em>What’s an Object, and what’s a Class?</em></strong></p>

<ul>
  <li>
    <p>What’s an object? It’s a bunch of instance variables, plus a link to a class. The object’s methods don’t live in the object—they live in the object’s class, where they’re called the instance methods of the class.</p>
  </li>
  <li>
    <p>What’s a class? It’s an object (an instance of Class), plus a list of instance methods and a link to a superclass. Class is a subclass of Module, so a class is also a module.</p>
  </li>
</ul>

<p><strong><em>What’s the difference between <code>load</code> and <code>require</code>?</em></strong></p>

<p>You use load to execute code, and you use require to import libraries.</p>

<ol>
  <li>use <code>require</code>, no need to appends ‘.rb’.</li>
  <li><code>require</code> loads only once.</li>
</ol>

<p><strong><em>As <code>load</code> executes codes, how does <code>load</code> avoid conlicts?</em></strong></p>

<p><code>load('motd.rb', true)</code></p>

<p>If you load a file this way, Ruby creates an anonymous module, uses that module as a Namespace to contain all the constants from motd.rb, and then destroys the module.</p>

<h2 id="constant">Constant</h2>

<p>classes are nothing but objects, class names are nothing but constants.</p>

<p><strong><em>How is a constant really different from a variable?</em></strong></p>

<p>The one important difference has to do with their scope.</p>

<p>Constants are arranged in a tree similar to a file system, where the names of modules and classes play the part of directories and regular constants play the part of files.</p>

<h2 id="method-lookup">Method lookup</h2>

<p><strong><em>What does Ruby do, when you call a method?</em></strong></p>

<ol>
  <li>It finds the method. This is a process called method lookup.</li>
  <li>It executes the method. To do that, Ruby needs something called <code>self</code>.</li>
</ol>

<p><strong><em>How does Ruby lookup methods?</em></strong></p>

<p><em>“one step to the right, then up”</em> rule: go one step to the right into the receiver’s class, and then go up the ancestors chain until you find the method.</p>

<p><strong><em>What does ancestor chain look like, when <code>prepend</code> or <code>include</code> multiple modules?</em></strong></p>

<p>The <code>prepend</code> method. It works like <code>include</code>, but it inserts the module below the including class.</p>

<p>```ruby
class C
  include M1
  include M2</p>

<p>prepend M3
  prepend M4
end</p>

<p>class D &lt; C; end</p>

<p>D.ancestors # =&gt; [‘M4’, ‘M3’, ‘C’, ‘M2’, ‘M1’]
```</p>

<p><strong><em>What does Ruby do, when <code>prepend</code> or <code>include</code> a module multiple times?</em></strong></p>

<p>If that module is already in the chain, Ruby silently ignores the second inclusion. As a result, a module can only appear once in the same chain of ancestors.</p>

<p><strong>Basic ancestor chain</strong></p>

<p><code>ruby
class MyClass; end
MyClass.ancestors # =&gt; [MyClass, Object, Kernel, BasicObject]
</code></p>

<p><strong><em>What <code>private</code> really means?</em></strong></p>

<p><code>private</code> methods come from two rules working together:</p>

<ol>
  <li>you need an explicit receiver to call a method on an object that is not yourself.</li>
  <li><code>private</code> methods can be called only with an <strong>implicit <code>self</code></strong>.</li>
</ol>

<p>Put these two rules together, and you’ll see that you can only call a <code>private</code> method on yourself. You can call this the “private rule.“</p>

<p><strong><em>What’s the env when you start the <code>irb</code>?</em></strong></p>

<p>As soon as you start a Ruby program, you’re sitting within an object named <code>main</code> that the Ruby interpreter created for you.</p>

<h2 id="refinement">Refinement</h2>

<p>Refinements are similar to Monkeypatches, but they’re not global. A Refinement is only active in two places:</p>

<ul>
  <li>The <code>refine</code> block itself.</li>
  <li>The code starting from the place where you call <code>using</code> until the end of the module definition (if you’re in a module definition) or the end of the file (if you’re at the top level).</li>
</ul>

<p><strong><em>Which has the precedence, Refinement or Method lookup?</em></strong></p>

<p>Refinements are like pieces of code patched right over a class, and they override normal method lookup. On the other hand, a Refinement works in a limited area of the program: the lines of code between the call to <code>using</code> and the end of the file, or the end of the module definition.</p>

<p>Code in an active Refinement takes precedence over code in the refined class, and also over code in modules that are included or prepended by the class. Refining a class is like slapping a patch right onto the original code of the class.</p>

<p>A trivia example about Refinement:</p>

<p>```ruby
class MyClass</p>

<p>def my_method
    “original my_method()”
  end</p>

<p>def another_method
    my_method
  end</p>

<p>end</p>

<p>module MyClassRefinement
  refine MyClass do
    def my_method
      “refined my_method()”
    end
  end
end</p>

<p>using MyClassRefinement
MyClass.new.my_method     # =&gt; “refine my_method()”
MyClass.new.another_method # =&gt; “original my_method()”
```</p>

<p>Even if you call <code>another_method</code> after the <code>using</code>, the call to <code>my_method</code> itself happens before the <code>using</code>—so it calls the original, unrefined version of the method.</p>

<p>A help reference, <a href="http://timelessrepo.com/refinements-in-ruby">Refinements in Ruby</a> by The timeless repository.</p>

<h1 id="methods">Methods</h1>

<h2 id="dynamic-dispatch">Dynamic Dispatch</h2>

<p>Why would you use <code>send</code> instead of the plain old dot notation? Because with <code>send</code>, the name of the method that you want to call becomes just a regular argument. You can wait literally until the very last moment to decide which method to call, while the code is running. This technique is called Dynamic Dispatch.</p>

<p><strong>An example of Dynamic Dispatch</strong></p>

<p>```ruby gems/pry-0.9.12.2/lib/pry/pry_instance.rb
def refresh(options={})
  defaults = {}
  attributes = [
          :input, :output, :commands, :print, :quiet,
          :exception_handler, :hooks, :custom_completions,
          :prompt, :memory_size, :extra_sticky_locals</p>

<pre><code>    ]
</code></pre>

<p>attributes.each do |attribute|
    defaults[attribute] = Pry.send attribute
  end</p>

<p># …</p>

<p>defaults.merge!(options).each do |key, value|
    send(“#{key}=”, value) if respond_to?(“#{key}=”)
  end</p>

<p>true
end
```</p>

<p><strong><em>What’s the concern about <code>send</code>?</em></strong></p>

<p>You can call any method with <code>send</code>, including private methods.</p>

<p>You can use <code>public_send</code> instead. It’s like send, but it makes a point of respecting the receiver’s privacy.</p>

<h2 id="dynamic-method">Dynamic Method</h2>

<p>There is one important reason to use <code>Module#define_method</code>(<strong>private</strong>) over the more familiar def keyword: <code>define_method</code> allows you to decide the name of the defined method at runtime.</p>

<h2 id="ghost-method">Ghost Method</h2>

<p><code>BasicObject#method_missing</code> (<strong>private</strong>)</p>

<p>Ghost Methods are usually icing on the cake, but some objects actually rely almost exclusively on them. They collect method calls through <code>method_missing</code> and forward them to the wrapped object.</p>

<p><strong><em>How can <code>respond_to?</code> missing methods?</em></strong></p>

<p>refernced from <a href="http://blog.marc-andre.ca/2010/11/15/methodmissing-politely/">Method_missing, Politely</a> by Marc Andre.</p>

<p>```ruby
class StereoPlayer
  def method_missing(method, *args, &amp;block)
    if method.to_s =~ /play_(\w+)/
      puts “Here’s #{$1}”
    else
      super
    end
  end
end</p>

<p>p = StereoPlayer.new
# ok:
p.play_some_Beethoven # =&gt; “Here’s some_Beethoven”
# not very polite:
p.respond_to? :play_some_Beethoven # =&gt; false</p>

<p>class StereoPlayer
  # def method_missing …
  #   …
  # end</p>

<p>def respond_to?(method, *)
    method.to_s =~ /play_(\w+)/ || super
  end
end
p.respond_to? :play_some_Beethoven # =&gt; true</p>

<p>```</p>

<p>You can specialize <code>respond_to?</code>, but it doesnot make a missing method behaves exactly like a method.</p>

<p><code>ruby
p.method :play_some_Beethoven
# =&gt; NameError: undefined method `play_some_Beethoven'
#               for class `StereoPlayer'
</code></p>

<p>Ruby 1.9.2 introduces <code>respond_to_missing?</code> that provides for a clean solution to the problem. Instead of specializing <code>respond_to?</code> one specializes <code>respond_to_missing?</code>.</p>

<p>```ruby
class StereoPlayer
  # def method_missing …
  #   …
  # end</p>

<p>def respond_to_missing?(method, *)
    method =~ /play_(\w+)/ || super
  end
end</p>

<p>p = StereoPlayer.new
p.play_some_Beethoven # =&gt; “Here’s some_Beethoven”
p.respond_to? :play_some_Beethoven # =&gt; true
m = p.method(:play_some_Beethoven) # =&gt; #&lt;Method: StereoPlayer#play_some_Beethoven&gt;
# m acts like any other method:
m.call # =&gt; “Here’s some_Beethoven”
m == p.method(:play_some_Beethoven) # =&gt; true
m.name # =&gt; :play_some_Beethoven
StereoPlayer.send :define_method, :ludwig, m
p.ludwig # =&gt; “Here’s some_Beethoven”
```</p>

<p><strong><em>What about the constant missing?</em></strong></p>

<p><code>Module#const_missing</code>(<strong>public</strong>)</p>

<p><strong><em>What’s the concern about <code>method_missing</code>?</em></strong></p>

<p>This is a common problem with Ghost Methods: since unknown calls become calls to <code>method_missing</code>, your object might accept a call that’s just plain wrong. Finding a bug like this one in a large program can be pretty painful.
To avoid this kind of trouble, take care not to introduce too many Ghost Methods.</p>

<p>Ghost Methods can be dangerous. You can avoid most of their problems by following a few basic recommendations (always call <code>super</code>, always redefine <code>respond_to_missing?</code>)</p>

<p>And you may call some methods <code>Object</code> or some others classes in ancestor chain defined.</p>

<p><strong><em>How to solve it? Blank Slate!</em></strong></p>

<p>Remove methods from an object to turn them into Ghost Methods.</p>

<ul>
  <li>Inheriting from <code>BasicObject</code> is the quicker way to define a Blank Slate in Ruby.</li>
</ul>

<p><code>ruby
im = BasicObject.instance_methods
im # =&gt; [:==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__]
</code></p>

<ul>
  <li>
    <p>Inheriting from <code>Object</code> by default, and remove method inherited.</p>

    <p>Don’t hide <code>instance_eval</code> or any method beginning with <code>__</code>. One example of a reserved method is <code>BasicObject#__send__</code>, that behaves the same as send, but gives you a scary warning when you try to remove it.</p>
  </li>
</ul>

<p><code>ruby
class Compter
  instance_methods.each do |m|
    undef_method m unless m.to_s =~ /^__|method_missing|respond_to/
  end
end
</code></p>

<ul>
  <li>Or you can write a BlankSlate class to inherit.</li>
</ul>

<p>```ruby
class BlankSlate</p>

<p>def self.hide(name)
    return unless instance_methods.include? name.to_s
    return if name.to_s =~ /^__|method_missing|respond_to/
    @hidden_methods ||= {}
    @hidden_methods[name.to_sym] = instance_method(name)
    undef_method name
  end</p>

<p>instance_methods.each{|m| hide m }
end
```</p>

<p><strong><em>What’s the difference between <code>undef_method</code> and <code>remove_method</code>?</em></strong></p>

<ul>
  <li>The drastic <code>undef_method</code> removes any method, including the inherited ones.</li>
  <li>The kinder <code>remove_method</code> removes the method from the receiver, but it leaves inherited methods alone.</li>
</ul>

<p><strong><em>What’s the boiling down facts between Ghost Method and really methods?</em></strong></p>

<p>Ghost Method are just a way to intercept method calls. Because of this fact, they behave different than actual methods.</p>

<p><strong><em>What’s the choice between <code>define_method</code> and <code>method_missing</code>?</em></strong></p>

<p>There are times when Ghost Methods are your only viable option. This usually happens</p>

<ul>
  <li>When you have a large number of method calls.</li>
  <li>When you don’t know what method calls you might need at runtime.</li>
</ul>

<p><em>Use Dynamic Methods if you can, and Ghost Methods if you have to.</em></p>

<h1 id="callables">Callables</h1>

<h2 id="the-callables">the Callables</h2>

<blockquote>
  <p>Package code, and call it later</p>
</blockquote>

<ul>
  <li><strong>block</strong>, evaluated in the scope which they’re defined.</li>
  <li><strong>proc</strong>, which is basically a block turned object, and evaluated in the scope which they’re defined.</li>
  <li><strong>lambda</strong>, which is a slight variation on a proc.</li>
  <li><strong>method</strong>, bound to an object, which are evaluated in that object’s scope. They can also be unbound from their scope and rebound to another object or class.</li>
</ul>

<p><strong>block</strong> is not an object, while <strong>proc</strong> and <strong>lambda</strong> are Proc objects, and <strong>method</strong> is <a href="http://stackoverflow.com/questions/2602340/methods-in-ruby-objects-or-not">in question</a>.</p>

<h2 id="blocks">Blocks</h2>

<p>The main point about blocks is that they are all inclusive and come ready to run. They contain both the <strong>code</strong> and <strong>a set of bindings</strong>.</p>

<p><strong>When you define the block, it simply grabs the bindings that are there at that moment</strong>, and then it carries those bindings along when you pass the block into a method.</p>

<p>```ruby
def my_method
  x = “Goodbye”
  yield(“cruel”)
end</p>

<p>x = “Hello”
my_method {|y| “#{x}, #{y} world” } # =&gt; “Hello, cruel world”
```</p>

<p><strong><em>What if I define additional bindings inside a block?</em></strong></p>

<p>They disappear after the block ends.</p>

<p><strong><em>What’s the meaning of “a block is a closure”?</em></strong></p>

<p>a block is a closure, this means a block captures the local bindings and carries them along with it.</p>

<p><strong>scope</strong></p>

<p>You can see bindings all over the scope.</p>

<p><code>class</code>, <code>module</code>, and <code>def</code>, respectively. Each of these keywords acts like a <strong>Scope Gate</strong>.</p>

<p><strong>A subtle difference between <code>class</code>, <code>module</code> and <code>def</code></strong></p>

<p>The code in a <code>class</code> or <code>module</code> definition is executed immediately. Conversely, the code in a method definition is executed later, when you eventually call the method.</p>

<p><strong><em>Whenever the program changes scope, some bindings are replaced by a new set of bindings. RIGHT?</em></strong></p>

<p>For <code>local_varialbes</code>, that’s right, but <code>instance_variables</code>, <code>class_variables</code> and <code>global_variables</code> can go through the Scope Gate.</p>

<p><strong><em>What’s the difference between Global Variables and Top-Level Instance Variables?</em></strong></p>

<p>when it comes to global variables, use them sparingly, if ever.</p>

<p>You can access a top-level instance variable whenever <code>main</code> takes the role of self. When any other object is <code>self</code>, the top-level instance variable is out of scope.</p>

<p><strong><em>How to cross the Scope Gate, and Why?</em></strong></p>

<p>You can use these techniques:</p>

<ul>
  <li>Use Flat Scope (<code>Class.new</code>, <code>Module.new</code>, and <code>define_method</code>)</li>
  <li>Use Shared Scope</li>
  <li>Use Context Probe (<code>BasicObject#instance_eval</code>)</li>
</ul>

<p>to mix code and bindings at will.</p>

<p><strong><em>What is Flat Scope?</em></strong></p>

<p>“flattening the scope,” meaning that the two scopes share variables as if the scopes were squeezed together. For short, you can call this spell a Flat Scope.</p>

<p>Use <code>Class.new</code>, <code>Module.new</code> and <code>define_method</code>.</p>

<p><strong><em>What is Shared Scope?</em></strong></p>

<p>```ruby
# use <code>def</code> to do seperate
def define_methods
  shared = 0</p>

<p>Kernel.send :define_method, :counter do
    shared
  end</p>

<p>Kernel.send :define_method, :inc do |x|
    shared += x
  end
end</p>

<p>define_methods</p>

<p>counter # =&gt; 0
inc(4)
counter # =&gt; 4
```</p>

<p>If you define multiple methods in the same Flat Scope, maybe protected by a Scope Gate, all those methods can share bindings. That’s called a <strong>Shared Scope</strong></p>

<p><strong><em>What is Context Probe?</em></strong></p>

<p><code>instance_eval</code> has a slightly more flexible twin brother named <code>instance_exec</code>, that allows you to pass arguments to the block.</p>

<p>```ruby
class C
  def initialize
    @x = 1
  end
end</p>

<p>class D
  def twisted_method
    @y = 2
    C.new.instance_eval { “@x: #{@x}, @y: #{@y}” }
  end
end</p>

<p>D.new.twisted_method # =&gt; “@x: 1, @y: “
```</p>

<p>However, instance variables depend on <code>self</code>, so when <code>instance_eval</code> switches <code>self</code> to the receiver, all the instance variables in the caller fall out of scope.</p>

<p><strong>Clean Room</strong></p>

<p>Blank Slates are good candidates for Clean Room.</p>

<p>The ideal Clean Room doesn’t have many methods or instance variables, because the names of those methods and instance variables could clash with the names in the environment that the block comes from. For this reason, instances of <code>BasicObject</code> usually make for good Clean Rooms, because they’re Blank Slates.</p>

<p>You might think of using a <code>BasicObject</code> instead of an Object for your Clean Room. However, remember that <code>BasicObject</code> is also a Blank Slate, and as such it lacks some common methods such as puts.</p>

<p><strong><em>What’s the different use for Shared Scope and Clean Room?</em></strong></p>

<p><em>Shared Scope</em> is used in definition, to make variables(bindings) shared between methods, while <em>Clean Room</em> is used to run code, to help reduce the modifications on shared variables(like instance variables).</p>

<p>```ruby
# lambda which is called immediatley is the Shared Scope
lambda {
  setups = []
  events = []</p>

<p>Kernel.send :define_method, :event do |description, &amp;block|
    events « 
  end</p>

<p>Kernel.send :define_method, :setup do |&amp;block|
    setups « block
  end</p>

<p>Kernel.send :define_method, :each_event do |&amp;block|
    events.each do |event|
      block.call event
    end
  end</p>

<p>Kernel.send :define_method, :each_setup do |&amp;block|
    setups.each do |setup|
      block.call setup
    end
  end
}.call</p>

<p>load ‘events.rb’</p>

<h1 id="env-is-created-for-each-event-to-be-a-clean-room">env is created for each event to be a Clean Room</h1>
<p>each_event do |event|
  env = Object.new
  each_setup do |setup|
    env.instance_eval &amp;setup
  end
  puts “ALERT: #{event[:description]}” if env.instance_eval &amp;(event[:condition])
end
```</p>

<p><strong><em>When is <code>yield</code> not enough to use?</em></strong></p>

<ul>
  <li>You want to pass the block to another method (or even another block).</li>
  <li>You want to convert the block to a <code>Proc</code>.</li>
</ul>

<h2 id="proc-objects">Proc Objects</h2>

<p>as blocks are not objects, Ruby provides the standard library class <code>Proc</code>. A <code>Proc</code> is a block that has been turned into an object. You can create a <code>Proc</code> by passing the block to <code>Proc.new</code>. Later, you can evaluate the block-turned-object with <code>Proc#call</code>.</p>

<p><strong>Deferred Evaluation</strong></p>

<p><code>ruby
inc = Proc.new {|x| x + 1 }
# more code...
inc.call(2) # =&gt; 3
</code></p>

<p><strong>4 ways to create Procs explicitly</strong></p>

<p><code>ruby
Proc.new {|x| x + 1 }
proc {|x| x + 1 }
lambda {|x| x + 1 }
-&gt; x { x + 1 } # stabby lambda
</code></p>

<p><strong>Ways to create Procs implicitly</strong></p>

<p>use <code>&amp;</code> to convert block into a proc:</p>

<p>```ruby
def make_proc(&amp;p)
  p
end</p>

<p>make_proc {|x| x + 1 }
```</p>

<p><strong>4 ways to call Procs</strong></p>

<p><code>ruby
p.call(41)
p[41]
p === 41
p.(41)
</code></p>

<p><strong>Use <code>&amp;</code> to convert a block to Proc</strong></p>

<p>```ruby
def my_method(&amp;the_proc)
  the_proc
end</p>

<p>p = my_method {|name| “Hello, #{name}!” }
p.class     # =&gt; Proc
p.call(“Bill”)  # =&gt; “Hello, Bill!”
```</p>

<p><strong>Use <code>&amp;</code> to convert a Proc to block</strong></p>

<p>```ruby
def my_method(greeting)
    “#{greeting}, #{yield}!”
end</p>

<p>my_proc = proc { “Bill” }
my_method(“Hello”, &amp;my_proc)
```</p>

<p><strong><em>What’s a lambda?</em></strong></p>

<p>Procs created with <code>lambda</code> are called <em>lambdas</em>, while the others are simply called <em>procs</em>. (You can use the <code>Proc#lambda?</code> method to check whether the <code>Proc</code> is a lambda).</p>

<p><strong>Procs vs. Lambdas</strong></p>

<ul>
  <li>
    <p><code>return</code></p>

    <p><code>lambda</code> returns just returns from the lambda, while a proc returns from the scope where the proc itself was defined.</p>
  </li>
  <li>
    <p><strong>arity</strong></p>

    <p>Call a <code>lambda</code> with the wrong arity, and it fails with an <code>ArgumentError</code>, while if there are too many arguments, a proc drops the excess arguments. If there are too few arguments, it assigns <code>nil</code> to the missing arguments.</p>
  </li>
</ul>

<p>Generally speaking, <code>lambdas</code> are more intuitive than procs because they’re more similar to methods. They’re pretty strict about arity, and they simply exit when you call <code>return</code>.</p>

<p><strong>About the tolerance on arguments</strong></p>

<p>method == lambda &lt; proc == block</p>

<h3 id="methods-1">Methods</h3>

<p>By calling <code>Kernel#method</code>, you get the method itself as a Method object, which you can later execute with <code>Method#call</code>. In Ruby 2.1, you also have <code>Kernel#singleton_method</code>, that converts the name of a Singleton Method to a Method object.</p>

<p><strong>Conversions between methods and procs</strong></p>

<ul>
  <li>Use <code>Method#to_proc</code> to convert a method into proc.</li>
  <li>Use <code>define_method</code> to convert a proc into method.</li>
</ul>

<p><strong>An important difference between methods and procs</strong></p>

<p>a <code>lambda</code> is evaluated in the scope it’s defined in (it’s a closure, remember?), while a <code>Method</code> is evaluated in the scope of its object.</p>

<h3 id="unbound-methods">Unbound Methods</h3>

<p><code>UnboundMethods</code> are like <code>Methods</code> that have been detached from their original class or module.</p>

<p><strong>You can’t call an <code>UnboundMethod</code></strong>, but you can use it to generate a normal method that you can call.</p>

<p><strong>generate</strong></p>

<ul>
  <li>use <code>Method#unbind</code></li>
</ul>

<p><code>ruby
def foo; end
unbound = method(:foo).unbind
unbound.class   # =&gt; UnboundMethod
</code></p>

<ul>
  <li>use <code>Module#instance_method</code></li>
</ul>

<p>```ruby
module MyModule
  def my_method
  42
  end
end</p>

<p>unbound = MyModule.instance_method(:my_method)
unbound.class   # =&gt; UnboundMethod
```</p>

<p><em>Note:</em> <code>instance_methods</code> is totally different, it’s like <code>methods</code>, just return an array of symbols.</p>

<p><strong>usage</strong></p>

<ul>
  <li>bind the UnboundMethod to an object with <code>UnboundMethod#bind</code>. UnboundMethods that come from a class can only be bound to objects of the same class (or a subclass), while UnboundMethods that come from a module have no such limitation from Ruby 2.0 onwards.</li>
  <li>use an UnboundMethod to define a brand new method by passing it to <code>Module#define_method</code>.</li>
</ul>

<p>```ruby
String.class_eval do
  define_method :another_method, unbound
end</p>

<p>“abc”.another_method # =&gt; 42
```</p>

<p><strong>example</strong></p>

<p>In ActiveSupport, the ‘autoloading’ system includes a <code>Loadable</code> module, which redefines the standard <code>Kernel#load</code>. If a class includes <code>Loadable</code>, then <code>Loadable#load</code> gets lower then <code>Kernel#load</code> on its chain of ancestors.</p>

<p>And what if you want to stop using <code>Loadable#load</code> and go back to the plain vanilla <code>Kernel#load</code>?</p>

<p><code>ruby # gems/activesupport-4.0.2/lib/active_support/dependencies.rb
module Loadable
  def exclude_from(base)
    base.class_eval { define_method :load, Kernel.instance_method(:load) }
  end
end
</code></p>

<h1 id="class-definitions">Class Definitions</h1>

<p>In Java and C#, defining a class is like making a deal between you and the compiler.</p>

<p>In Ruby, class definitions are different. When you use the class keyword, you aren’t just dictating how objects will behave in the future. On the contrary, you’re actually running code.</p>

<h2 id="the-current-class">The Current Class</h2>

<p>Wherever you are in a Ruby program, you always have a current object: <code>self</code>. Likewise, you always have a current class (or module). As The Ruby interpreter always keeps a reference to the current class (or module), when you define a method, that method becomes an instance method of the current class.</p>

<p>Although you can get a reference to the current object through <code>self</code>, there’s no equivalent keyword to get a reference to the current class.</p>

<p><strong><em>How to keep track of the current class?</em></strong></p>

<ul>
  <li>At the top level of your program, the current class is <code>Object</code>, the class of <code>main</code>. (That’s why, if you define a method at the top level, that method becomes an instance method of <code>Object</code>).</li>
</ul>

<p><code>ruby
def foo; puts 'foo'; end
Object.instance_methods.grep(:foo)      # =&gt; []
Object.private_instance_methods.grep(:foo) # =&gt; [:foo]
</code></p>

<p>```ruby
[6] pry(main)&gt; def foo; puts ‘foo’; end
=&gt; nil
[7] pry(main)&gt; cd Object
[8] pry(Object):1&gt; show-method foo</p>

<p>From: (pry) @ line 4:
Owner: Object
Visibility: private
Number of lines: 1</p>

<p>def foo; puts ‘foo’; end
[9] pry(Object):1&gt; cd ..
```</p>

<p>```ruby
# foo.rb
def foo; puts ‘foo’; end
p Object.private_instance_methods.grep(:foo) # =&gt; [:foo]</p>

<h1 id="console">console</h1>
<p>$ ruby foo.rb # =&gt; [:foo]
```</p>

<ul>
  <li>
    <p>In a method, the current class is the class of the current object.</p>
  </li>
  <li>
    <p>When you open a class with the <code>class</code> keyword (or a module with the <code>module</code> keyword), that class becomes the current class.</p>
  </li>
</ul>

<p><strong><em>How can you open the class if you don’t know its name?</em></strong></p>

<p>Use <code>Module#class_eval</code>.</p>

<p><strong><em>What’s the advantage of <code>Module#class_eval</code> other than <code>class</code>?</em></strong></p>

<ul>
  <li><code>Module#class_eval</code> is actually more flexible than class. You can use <code>class_eval</code> on any variable that references the class, while <code>class</code> requires a constant.</li>
  <li><code>class</code> opens a new scope, losing sight of the current bindings, while <code>class_eval</code> has a <em>Flat Scope</em>.</li>
</ul>

<p><strong><em>When to use <code>class_eval</code>, and when <code>instance_eval</code>?</em></strong></p>

<p>Use <code>instance_eval</code> to open an object that is not a class, and <code>class_eval</code> to open a class definition and define methods with <code>def</code>.</p>

<p><strong><em>What’s the difference between <code>class_eval</code> and <code>instance_eval</code>?</em></strong></p>

<p>Both changes <code>self</code>, and <code>class_eval</code> changes the current class to the caller’s class, while <code>instance_eval</code> changes the current class to the caller’s singleton class.</p>

<p><strong>An interesting knowledge about <code>Class.new</code></strong></p>

<p>```ruby
c = Class.new(Array) do
  def my_method
    ‘Hello!’
  end
end</p>

<p>MyClass = c
c.name  # =&gt; ‘MyClass’
```</p>

<p>When you assign an anonymous class to a constant, Ruby understands that you’re trying to give a name to the class, and it does something special: it turns around to the class and says, “Here’s your new name.” Now the constant references the Class, and the Class also references the constant. If it weren’t for this trick, a class wouldn’t be able to know its own name</p>

<h2 id="class-instance-variables">Class Instance Variables</h2>

<p>They’re just regular instance variables that happen to belong to an object of class <code>Class</code>. Because of that, a Class Instance Variable can be accessed only by the class itself— not by an instance or by a subclass.</p>

<p>No weird behaviors like Class Variables, which subclass and class share the same variable.</p>

<h2 id="singleton-methods">Singleton Methods</h2>

<p><code>ruby
obj = Object.new
def obj.foo; puts 'foo'; end
</code></p>

<p>A method which is specific to a single object, is called Singleton Methods.</p>

<p>You can also use <code>Object#define_singleton_method</code>: (Remeber <code>Module#define_method</code>?)</p>

<p><code>ruby
obj.define_singleton_method :bar { puts 'bar' }
</code></p>

<p><strong><em>What is the Class Macro?</em></strong></p>

<p>A method such as <code>attr_accessor</code> is called a Class Macro. Class Macros look like keywords, but they’re just regular class methods that are meant to be used in a class definition.</p>

<h2 id="singleton-class">Singleton Class</h2>

<p>A singleton class is where an object’s Singleton Methods live</p>

<p><strong><em>How to get?</em></strong></p>

<ul>
  <li>Use the <code>&lt;&lt;</code> syntax.</li>
</ul>

<p><code>ruby
def obj.my_singleton_method; end
class &lt;&lt; obj; instance_methods.grep(/my_/); end
</code></p>

<p>```ruby
class Foo
  class « self
    def bar; puts ‘Foo.bar’; end
  end
end</p>

<p>foo = Foo.new
class « foo
  def bar; puts ‘foo.bar’; end
end
```</p>

<ul>
  <li>Use <code>Object#singleton_class</code></li>
</ul>

<p><code>ruby
obj.singleton_class.instance_methods.grep(/my_/)
</code></p>

<p><strong>Singleton classes and inheritance</strong></p>

<p><img src="https://dl.dropboxusercontent.com/s/leu6dh1ro55u149/singleton_classes_and_inheritance.png?dl=1&amp;token_hash=AAFdcu5UXq5RMpm7nkaQf_B5Und9FjuPF85b35aIWXjC1g&amp;expiry=1400340965" alt="singleton_classes_and_inheritance" /></p>

<p><strong>7 rules of the Ruby object model</strong></p>

<blockquote>
  <p>The Ruby object model is a beautiful place,” Bill notes, with a dreamy expres- sion on his face. “There are classes, singleton classes, and modules. There are instance methods, class methods, and singleton methods.</p>
</blockquote>

<ol>
  <li>There is only one kind of object—be it a regular object or a module.</li>
  <li>There is only one kind of module—be it a regular module, a class, or a singleton class.</li>
  <li>There is only one kind of method, and it lives in a module—most often in a class.</li>
  <li>Every object, classes included, has its own “real class,” be it a regular class or a singleton class.</li>
  <li>Every class, with the exception of <code>BasicObject</code>, has exactly one ancestor— either a superclass, or a module. This means you have a single chain of ancestors from any class up to <code>BasicObject</code>.</li>
  <li>The superclass of the singleton class of an object is the object’s class. The superclass of the singleton class of a class is the singleton class of the class’s superclass.</li>
  <li>When you call a method, Ruby goes “right” in the receiver’s real class and then “up” the ancestors chain. That’s all there is to know about the way Ruby finds methods.</li>
</ol>

<p><strong><em>Can object’s Singleton Class touch the its Instance Variable?</em></strong></p>

<p>```ruby
# exampel 1</p>

<p>class MyClass
  def name; @name; end
  def name=(n); @name=n; end
end</p>

<p>obj = MyClass.new
obj.name = ‘foo’
obj.name # =&gt; ‘foo’</p>

<p>obj.instance_eval { def to_s; “My name is #@name”; end }
obj.to_s # =&gt; “My name is foo”</p>

<h1 id="example2">example2</h1>

<p>class MyClass
  @age = 42
  class « self
    def age; @age; end
  end
end</p>

<p>MyClass.age # =&gt; 42
```</p>

<p>Yes, it can. So I can assume the obj’s Instance Variable lives in its Singleton Class.</p>

<p><strong><em>Can a module’s singleton methods be included?</em></strong></p>

<p>No!</p>

<p>When a class includes a module, it gets the module’s instance methods—not the class methods. Class methods stay out of reach, in the module’s singleton class.</p>

<p>```ruby
module M
  def foo; puts ‘foo’; end
  def self.bar; puts ‘bar’; end
end</p>

<p>class C
  include M
end</p>

<p>C.new.foo # =&gt; ‘foo’
C.new.bar # =&gt; NoMethodError</p>

<p>class C
  extend M
end</p>

<p>C.bar # =&gt; NoMethodError
C.foo # =&gt; ‘foo’
```</p>

<p><strong><em>What’s the difference between <code>Module#include</code> and <code>Object#extend</code>?</em></strong></p>

<ul>
  <li><code>Module#include</code> includes a module in the receiver’s class.</li>
  <li><code>Object#extend</code> includes a module in the receiver’s singleton class.</li>
</ul>

<h2 id="method-wrapper">Method Wrapper</h2>

<ul>
  <li>Around Alias</li>
  <li>Refinement Wrapper</li>
  <li>Prepended Wrapper(<code>Module#prepend</code>)</li>
</ul>

<p>Selection: Prepended Wrapper &gt; Refinement Wrapper &gt; Around Alias</p>

<h3 id="around-alias">Around Alias</h3>

<p><strong><code>alias</code> vs. <code>alias_method</code></strong></p>

<p><code>ruby
class MyClass
  alias :new_foo :foo
  alias_method :another_new_foo, :foo
end
</code></p>

<ul>
  <li><code>alias</code> is a keyword.</li>
  <li><code>alias_method</code> is an instance method of Module. <code>Module#alias_method</code></li>
</ul>

<p><strong><em>Can you alias a method before it defined?</em></strong></p>

<p>No!</p>

<p>```ruby
class MyClass
  alias_method :new_foo, :foo
  def foo; puts ‘foo’; end
end</p>

<h1 id="nameerror-undefined-method-foo-for-class-myclass">=&gt; NameError: undefined method <code>foo' for class </code>MyClass’</h1>
<p>```</p>

<p><strong><em>Can aliases break the class’s encapsulation?</em></strong></p>

<p>Yes!</p>

<p>```ruby
class MyClass
  alias_method :new_foo, :foo</p>

<p>private
    def foo; puts ‘foo’; end
  end</p>

<p>MyClass.new.foo     # =&gt; NoMethodError: private method <code>foo' called
  MyClass.new.new_foo # =&gt; 'foo'
</code>``</p>

<p><strong><em>How to write an Around Alias?</em></strong></p>

<ol>
  <li>You alias a method.</li>
  <li>You redefine it.</li>
  <li>You call the old method from the new method.</li>
</ol>

<p><strong>Downsides</strong></p>

<ul>
  <li>They pollute your classes with one additional method name. You can fix this small problem somehow by making the old version of the method <code>private</code> after you alias it.</li>
  <li>The loading issue. You should never load an Around Alias twice, unless you want to end up with an exception when you call the method.</li>
</ul>

<p>The main issue with Around Aliases, however, is that they are a form of Monkeypatching. Like all Monkeypatches, they can break existing code that wasn’t expecting the method to change.</p>

<h3 id="refinement-wrapper">Refinement Wrapper</h3>

<p><strong>Advantage over Around Alias</strong></p>

<p>If you call <code>super</code> from a refined method, you will call the original, unrefined method.</p>

<p>```ruby
module StringRefinement
  refine String do
    def length
      super &gt; 5 ? ‘long’ : ‘short’
    end
  end
end</p>

<p>using StringRefinement
“War and Peace”.length # =&gt; “long”
```</p>

<h3 id="prepended-wrapper">Prepended Wrapper</h3>

<p>A method in a prepended module can override a method in the includer, and call the non- overridden version with <code>super</code>.</p>

<p>```ruby
module ExplicitString
  def length
    super &gt; 5 ? ‘long’ : ‘short’
  end
end</p>

<p>String.class_eval do
  prepend ExplicitString
end</p>

<p>“War and Peace”.length # =&gt; “long”
```</p>

<p><strong><em>Advantage over Refinement Wrapper and Around Alias?</em></strong></p>

<p>It’s generally considered cleaner and more explicit than both a Refinement Wrapper and an Around Alias.</p>

<h3 id="an-interesting-quiz-solving-by-around-alias">An interesting quiz solving by Around Alias</h3>

<p>Make it work:</p>

<p><code>ruby
1 + 1 # =&gt; 3
</code></p>

<p>You can solve this quiz with an Open Class. Just reopen <code>Fixnum</code>, and redefine <code>+</code> so that <code>(x+y)</code> becomes <code>(x+y+1)</code>. This is not as easy as it seems, however. The new version of + relies on the old version of +, so you need to wrap your old version with the new version.</p>

<p>```ruby
class Fixnum
  alias_method :old_plus, :+</p>

<p>def +(value)
    self.old_plus(value).old_plus(1)
  end
end
```</p>

<h1 id="eval-and-binding">Eval and Binding</h1>

<p><code>Kernel#eval</code> Evaluates the Ruby expression(s) in string. If binding is given, which must be a <code>Binding</code> object, the evaluation is performed in its context.</p>

<p>```ruby
def get_binding(str)
  binding
end</p>

<p>str = ‘hello’
eval “str + ‘ Fred’”                     # =&gt; “hello Fred”
eval “str + ‘ Fred’”, get_binding(‘bye’) # =&gt; “bye Fred”
```</p>

<p><code>Kernel#binding</code> Returns a <code>Binding</code> object, describing the variable and method bindings at the point of call. This object can be used when calling eval to execute the evaluated command in this environment.</p>

<p>Ruby also provides a predefined constant named <code>TOPLEVEL_BINDING</code>, which is just a Binding of the top-level scope.</p>

<p>You can also use <code>Proc#binding</code> to return a <code>Binding</code> object.</p>

<p>```ruby
def get_proc(str)
  -&gt; {}
end</p>

<p>eval “str + ‘Fred’”, get_proc(‘bye’).binding # =&gt; “bye Fred”
```</p>

<p>```ruby
l = -&gt; { name = ‘wendi’ }
eval “puts name”, l.binding
# =&gt; NameError: undefined local variable or method <code>name' for main:Object</code></p>

<p>def bar
  name = ‘wendi’
  -&gt; {}
end
eval “puts name”, bar.binding
# =&gt; wendi
```</p>

<p><strong><em>What’s to concern when using <code>eval</code>?</em></strong></p>

<ul>
  <li>
    <p>As it only accepts strings of codes but not blocks, it’s not editor friendly(syntax highlighting) and hard to trace syntax errors.</p>
  </li>
  <li>
    <p>Code Injection.</p>
  </li>
</ul>

<p><strong><em>What’s the soluction Ruby provided for <code>eval</code> insecurity?</em></strong></p>

<ul>
  <li>
    <p>Tainted Objects, <code>Object#tainted?</code>, <code>Object#untaint</code></p>
  </li>
  <li>
    <p>Safe Levels, <code>$SAFE</code></p>

    <ul>
      <li>0, “hippie commune”, where you can hug trees and format hard disks.</li>
      <li>Any safe level greater than 0 also causes Ruby to flat-out refuse to evaluate tainted string.</li>
      <li>2, disallows most file-related operations.</li>
      <li>3, “military dictatorship,” where every object you create is tainted by default.</li>
    </ul>
  </li>
</ul>

<p><strong><em>How to write a Sandbox for <code>eval</code>?</em></strong></p>

<p><code>ruby
class ERB
  def result(b=new_toplevel)
    if @safe_level
      proc {
        $SAFE = @safe_level
        eval(@src, b, (@filename || '(erb)'), 0)
      }.call
    else
      eval(@src, b, (@filename || '(erb)'), 0)
    end
  end
end
</code></p>

<p><em>Updated 2014-09-28</em></p>

<p>As I was looking API and fiddling around, I found 3 new methods only supported by Ruby 2.1.</p>

<p>```ruby
def foo
  a = 1</p>

<p>binding.local_variable_defined?(:a) # =&gt; true
  # binding.eval(“defined?(#{symbol}) == ‘local-variable’”)</p>

<p>binding.local_variable_get(:a) #=&gt; 1
  # binding.eval(“#{symbol}”)</p>

<p>binding.local_variable_set(:a, 2) #=&gt; 2
  # binding.eval(“#{symbol} = #{obj}”)
end
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Review]  长发飞扬的日子]]></title>
    <link href="http://blog.ifyouseewendy.com/blog/2014/06/03/jiang-xin-chang-fa-fei-yang-de-ri-zi/"/>
    <updated>2014-06-03T00:34:18+08:00</updated>
    <id>http://blog.ifyouseewendy.com/blog/2014/06/03/jiang-xin-chang-fa-fei-yang-de-ri-zi</id>
    <content type="html"><![CDATA[<table class="custom">
  <tbody>
    <tr>
      <td><strong>Book</strong></td>
      <td>长发飞扬的日子</td>
    </tr>
    <tr>
      <td><strong>Author</strong></td>
      <td>姜昕</td>
    </tr>
    <tr>
      <td><strong>Link</strong></td>
      <td><a href="http://book.douban.com/subject/6189764/">book.douban.com/subject/6189764</a></td>
    </tr>
  </tbody>
</table>

<p>阴雨连绵会让我觉得他是，好天气反而会让我坐立不安。</p>

<p>我久久地注视着那个方向，终于明白其实我们都只是在寻找我们各自的过去，而那种寻找是徒劳的。</p>

<p>爱是一种在一瞬间就忽然降临的东西，是让你猝不及防却又挥之不去的东西。如果你犹豫再三，如果你反复掂量，那它就掺进了杂质，变成了表面上与爱情类似却又远不能急的另一种情感。</p>

<p>虽然我和夏旸后来分开了，彼此也都曾给对方造成过伤害，可是，我从不怀疑他曾经对我说过的誓言——因为后来我终于知道了：誓言不见得是会实现的——年轻的誓言其实是你一生中曾经绽放的最绚烂的花朵。等到有一天，你再也听不到它而且自己也不会再说的时候，其实，那正是成长的悲哀。</p>

<p>所以，对摇滚乐这一名词，我是这样理解的：它就像当初崔健诠释他自己的名字的那句话——就是一种“摧毁”和一种“建立”。它不应该局限于任何一种和声走势，也不应该局限于任何一种表演形式或表面现象，它是“点燃”，用从一些心灵发出的声音将另外一些心灵“点燃”。</p>

<p>崔健说得特别号：“我没有老，因为我还有质疑这个世界的能力！”</p>

<p>他找到了新的方向——那一切的改变，是因为 <a href="http://en.wikipedia.org/wiki/Peter_Murphy_(musician\)">Peter Murphy</a> 在 Bauhaus 时期的两张唱片——<a href="http://www.xiami.com/album/50278?spm=0.0.0.0.vuZDIm">In The Flat Field</a>、<a href="http://www.xiami.com/album/50279?spm=0.0.0.0.vuZDIm">Mask</a>，尤其是他离开乐队之后发行的那张个人专辑 <a href="http://www.xiami.com/album/55495?spm=0.0.0.0.7DIi01">Deep</a>。</p>

<p>很多年后回头再看，我才真正意识到当年那么年轻的他能做到这一点有多么难得，他并没有因为一时的成功就忘乎所以、不可一世。而能够在名利双收的时候选择离开、在功成名就以后仍然一直将自己的注意力放在音乐上，这样的人一直是我敬佩的。</p>

<p>生活并不像我们最初想象的那样，可是，好天气还会有，所以，最傻的事情就是在一个阴霾的天气中绝望。</p>

<p>– “这些天我一直在想，当初选择做音乐到底是为了什么？难道就是为了出唱片，被好多人捧着、盯着？可那样幸福吗？”<br />
– “可你舍得放弃吗？那样你就会觉得幸福了吗？”
– “要是有一天我做的音乐一钱不值，再没有人说它们好，你会怎么想？会失望吗？”<br />
– “不会的！我相信你！”
– “所以说，这是条‘贼船’，上去就很难下来了！连你都这么想——不会的！的确，我是舍不得放弃，我已经‘中毒‘太深了……可是我怎么觉得，我的幸福也都被它毁了……我不知道我在对谁负责、谁又能对我负责！”</p>

<p>今年年初，一个偶然的早晨，我们坐在“永和豆浆”一起吃早点，又谈起那段往事，我说：“还记得吗？你那个无比美好的理想。可是为什么在我告诉你我已经爱上另一个男人的时候，你又掐着我的脖子把我堵在墙角里了？还说女人真狠！得承认你还是自私的吧？”</p>

<p>那天晚上，我拆开那个信封，里边是一张白色的硬纸壳儿，上边是一个“梦”字，不过那不仅仅是一个字，那其实是一幅画。上边“林”字的“横撇竖捺”画的是牛仔裤的侧面、牙膏牙刷、烟、打火机和笔；下面“夕”字的两撇是我和他的背影；一横是一张一百块钱的正面，四个“老人”换成了他乐队的四个人，发型怪异戴着墨镜，其中三个还分别拿着吉他、贝斯和鼓槌，那一点则是一个“？”。</p>

<p>信封里没有照片，也没有画，那同样是两张牛皮纸，只不过比信封的质地稍薄，背面是放大的石膏头像，右上角印着四行小字：</p>

<ul>
  <li>多而乱的皱纹是岁月层层叠叠的刻度  </li>
  <li>大小深浅的斑点是过去的记忆  </li>
  <li>这就是平稳平淡的艺术生活  </li>
  <li>创造出丰富的艺术生命  </li>
</ul>

<p>最后面是四个大字：  </p>

<ul>
  <li>留驻记忆</li>
</ul>

<p>如果有一天，一个人能够面容坦然地说：I’m alone, but not lonely。我以为那样的他（她）才是真的成熟了——所以，我最欣赏的气质，是坦然。</p>

<p>当我们的路通向另一个黑暗森林，追寻来时的脚步是多么困难！当路被设定好了，回归似乎不可能。生命就是我们的契约，但是除了最高法庭之外，无人能撤销它；在这样的夜里，死亡看来非常遥远，可是我们知道这是自欺欺人。我们没有时间看见最暗淡的星自我们眼角消失。当它们熄灭，我们会等待更明亮的傍晚。或者，瞻仰它们的光彩，让我们多么焦虑。我从不知有任何快乐可以不带来焦虑。但我们很愿意付出这样的代价……
– Emily Dickenson</p>

<p>那天晚上，他们玩过一个游戏，用一本不知被谁一摞的成语字典彼此算命。每个轮到的人随意选择一个页数，并且选择那一页从上到下的某个成语。大家试过，都觉得准的不行！他们是按照年龄顺序进行的，最后轮到峻峻，他是乐队里年龄最小的一个。他那一条是——风流云散。</p>

<p>仅仅两年多的时间，让一个人从“长发飞扬”到“怪毛林立”，再到“一毛不拔”，这选择和放弃到底意味着什么呢？</p>

<p>门厅中最惨烈的就是那个杯子，它粉身碎骨在一滩水渍中，就像那是它的血。</p>

<p>我们都失败过，所以应该更加懂得怎么去保护我们的镜子。他还说，我们不要像从前那样，在一份感情里交付盲目的热情，我们唯一需要交付的，是自己心里的坦然。这个世界的诱惑很多，可我们必须明白——每一次心旌摇动，即使对方不知道，那面镜子也照得见，而且它会出现裂痕。所以，如果我们只想一位地任随心意，就不要在一起；如果打算在一起，就不要欺骗那面镜子。</p>

]]></content>
  </entry>
  
</feed>
